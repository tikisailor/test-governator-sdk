/* tslint:disable */
/* eslint-disable */
/**
 * Governator API
 * REST API for Governator
 *
 * The version of the OpenAPI document: 1.0.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountBase
 */
export interface AccountBase {
    /**
     * account id
     * @type {string}
     * @memberof AccountBase
     */
    '_id'?: string;
    /**
     * Governator user ID
     * @type {string}
     * @memberof AccountBase
     */
    'user_id': string;
    /**
     * account provider id
     * @type {string}
     * @memberof AccountBase
     */
    'provider_id': string;
    /**
     * Datetime when record was created
     * @type {string}
     * @memberof AccountBase
     */
    'createdAt'?: string;
    /**
     * Datetime when record was last updated
     * @type {string}
     * @memberof AccountBase
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ClientConfigBase
 */
export interface ClientConfigBase {
    /**
     * Provider id
     * @type {string}
     * @memberof ClientConfigBase
     */
    'provider_id': string;
}
/**
 * 
 * @export
 * @interface CommunityAdministratorBase
 */
export interface CommunityAdministratorBase {
    /**
     * Provider id
     * @type {string}
     * @memberof CommunityAdministratorBase
     */
    'provider_id': string;
}
/**
 * 
 * @export
 * @interface CommunityClientConfigBase
 */
export interface CommunityClientConfigBase {
    /**
     * Provider id
     * @type {string}
     * @memberof CommunityClientConfigBase
     */
    'provider_id': string;
}
/**
 * 
 * @export
 * @interface CommunityCreateDto
 */
export interface CommunityCreateDto {
    /**
     * Community Name
     * @type {string}
     * @memberof CommunityCreateDto
     */
    'name': string;
    /**
     * Administrators of this community
     * @type {Array<CommunityAdministratorBase>}
     * @memberof CommunityCreateDto
     */
    'administrators': Array<CommunityAdministratorBase>;
    /**
     * Client config for this community
     * @type {Array<CommunityClientConfigBase>}
     * @memberof CommunityCreateDto
     */
    'client_config': Array<CommunityClientConfigBase>;
}
/**
 * 
 * @export
 * @interface CommunityResponseDto
 */
export interface CommunityResponseDto {
    /**
     * Community ID - (auto generated if left blank)
     * @type {string}
     * @memberof CommunityResponseDto
     */
    '_id'?: string;
    /**
     * Community Name
     * @type {string}
     * @memberof CommunityResponseDto
     */
    'name': string;
    /**
     * Administrators of this community
     * @type {Array<CommunityAdministratorBase>}
     * @memberof CommunityResponseDto
     */
    'administrators': Array<CommunityAdministratorBase>;
    /**
     * Client config for this community
     * @type {Array<CommunityClientConfigBase>}
     * @memberof CommunityResponseDto
     */
    'client_config': Array<CommunityClientConfigBase>;
    /**
     * Datetime when record was created
     * @type {string}
     * @memberof CommunityResponseDto
     */
    'createdAt'?: string;
    /**
     * Datetime when record was last updated
     * @type {string}
     * @memberof CommunityResponseDto
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface CommunityUpdateDto
 */
export interface CommunityUpdateDto {
    /**
     * Community Name
     * @type {string}
     * @memberof CommunityUpdateDto
     */
    'name'?: string;
    /**
     * Administrators of this community
     * @type {Array<CommunityAdministratorBase>}
     * @memberof CommunityUpdateDto
     */
    'administrators'?: Array<CommunityAdministratorBase>;
    /**
     * Client config for this community
     * @type {Array<CommunityClientConfigBase>}
     * @memberof CommunityUpdateDto
     */
    'client_config'?: Array<CommunityClientConfigBase>;
}
/**
 * 
 * @export
 * @interface DiscordAccountCreateDto
 */
export interface DiscordAccountCreateDto {
    /**
     * Discord user Id
     * @type {string}
     * @memberof DiscordAccountCreateDto
     */
    '_id': string;
    /**
     * Discord username
     * @type {string}
     * @memberof DiscordAccountCreateDto
     */
    'discord_username': string;
}
/**
 * 
 * @export
 * @interface DiscordAccountResponseDto
 */
export interface DiscordAccountResponseDto {
    /**
     * Discord user Id
     * @type {string}
     * @memberof DiscordAccountResponseDto
     */
    '_id': string;
    /**
     * Governator user ID
     * @type {string}
     * @memberof DiscordAccountResponseDto
     */
    'user_id': string;
    /**
     * account provider id
     * @type {string}
     * @memberof DiscordAccountResponseDto
     */
    'provider_id': string;
    /**
     * Datetime when record was created
     * @type {string}
     * @memberof DiscordAccountResponseDto
     */
    'createdAt'?: string;
    /**
     * Datetime when record was last updated
     * @type {string}
     * @memberof DiscordAccountResponseDto
     */
    'updatedAt'?: string;
    /**
     * Discord username
     * @type {string}
     * @memberof DiscordAccountResponseDto
     */
    'discord_username': string;
}
/**
 * 
 * @export
 * @interface DiscordAccountUpdateDto
 */
export interface DiscordAccountUpdateDto {
    /**
     * Governator user ID
     * @type {string}
     * @memberof DiscordAccountUpdateDto
     */
    'user_id'?: string;
    /**
     * Discord username
     * @type {string}
     * @memberof DiscordAccountUpdateDto
     */
    'discord_username'?: string;
}
/**
 * 
 * @export
 * @interface DiscordResponseDto
 */
export interface DiscordResponseDto {
    /**
     * Unique Id of this request (as received from request)
     * @type {string}
     * @memberof DiscordResponseDto
     */
    'uuid': string;
    /**
     * Id of data provider (e.g. discord)
     * @type {string}
     * @memberof DiscordResponseDto
     */
    'provider_id': string;
    /**
     * Datasource Id
     * @type {string}
     * @memberof DiscordResponseDto
     */
    'method': string;
    /**
     * Datasource Id
     * @type {string}
     * @memberof DiscordResponseDto
     */
    'guildId': string;
    /**
     * Requested data
     * @type {Array<object>}
     * @memberof DiscordResponseDto
     */
    'data': Array<object>;
}
/**
 * 
 * @export
 * @interface ERC1155BalanceOfDto
 */
export interface ERC1155BalanceOfDto {
    /**
     * ERC721 token contract address
     * @type {string}
     * @memberof ERC1155BalanceOfDto
     */
    'contractAddress': string;
    /**
     * Chain Id
     * @type {number}
     * @memberof ERC1155BalanceOfDto
     */
    'chain_id': number;
    /**
     * Block number at which the token balance will be checked
     * @type {number}
     * @memberof ERC1155BalanceOfDto
     */
    'block_height'?: number;
    /**
     * Array of ERC721 token IDs to query for ownership
     * @type {number}
     * @memberof ERC1155BalanceOfDto
     */
    'token_id': number;
}
/**
 * 
 * @export
 * @interface ERC20BalanceOfDto
 */
export interface ERC20BalanceOfDto {
    /**
     * ERC20 token contract address
     * @type {string}
     * @memberof ERC20BalanceOfDto
     */
    'contractAddress': string;
    /**
     * Chain Id
     * @type {number}
     * @memberof ERC20BalanceOfDto
     */
    'chain_id': number;
    /**
     * Block number at which the token balance will be checked
     * @type {number}
     * @memberof ERC20BalanceOfDto
     */
    'block_height'?: number;
}
/**
 * 
 * @export
 * @interface ERC20TokenBalanceDetail
 */
export interface ERC20TokenBalanceDetail {
    /**
     * ERC20 token contract address
     * @type {string}
     * @memberof ERC20TokenBalanceDetail
     */
    'contractAddress': string;
    /**
     * Chain Id
     * @type {number}
     * @memberof ERC20TokenBalanceDetail
     */
    'chain_id': number;
    /**
     * ERC20 token name
     * @type {string}
     * @memberof ERC20TokenBalanceDetail
     */
    'tokenName': string;
    /**
     * ERC20 token symbol
     * @type {string}
     * @memberof ERC20TokenBalanceDetail
     */
    'tokenSymbol': string;
    /**
     * ERC20 token balance
     * @type {string}
     * @memberof ERC20TokenBalanceDetail
     */
    'balance': string;
    /**
     * Block number at which the token balance will be checked
     * @type {number}
     * @memberof ERC20TokenBalanceDetail
     */
    'block_height'?: number;
}
/**
 * 
 * @export
 * @interface ERC20TokenBalances
 */
export interface ERC20TokenBalances {
    /**
     * Ethereum account address
     * @type {string}
     * @memberof ERC20TokenBalances
     */
    'account': string;
    /**
     * Array of ERC20 token balances
     * @type {Array<ERC20TokenBalanceDetail>}
     * @memberof ERC20TokenBalances
     */
    'tokenBalances': Array<ERC20TokenBalanceDetail>;
}
/**
 * 
 * @export
 * @interface ERC721OwnerOfDto
 */
export interface ERC721OwnerOfDto {
    /**
     * ERC721 token contract address
     * @type {string}
     * @memberof ERC721OwnerOfDto
     */
    'contractAddress': string;
    /**
     * Chain Id
     * @type {number}
     * @memberof ERC721OwnerOfDto
     */
    'chain_id': number;
    /**
     * Array of ERC721 token IDs to query for ownership
     * @type {Array<TokenIdsDto>}
     * @memberof ERC721OwnerOfDto
     */
    'token_ids': Array<TokenIdsDto>;
    /**
     * Block number at which the token balance will be checked
     * @type {number}
     * @memberof ERC721OwnerOfDto
     */
    'block_height'?: number;
}
/**
 * 
 * @export
 * @interface EthereumAccountCreateDto
 */
export interface EthereumAccountCreateDto {
    /**
     * Ethereum address
     * @type {string}
     * @memberof EthereumAccountCreateDto
     */
    '_id': string;
}
/**
 * 
 * @export
 * @interface EthereumAccountResponseDto
 */
export interface EthereumAccountResponseDto {
    /**
     * Ethereum address
     * @type {string}
     * @memberof EthereumAccountResponseDto
     */
    '_id': string;
    /**
     * Governator user ID
     * @type {string}
     * @memberof EthereumAccountResponseDto
     */
    'user_id': string;
    /**
     * account provider id
     * @type {string}
     * @memberof EthereumAccountResponseDto
     */
    'provider_id': string;
    /**
     * Datetime when record was created
     * @type {string}
     * @memberof EthereumAccountResponseDto
     */
    'createdAt'?: string;
    /**
     * Datetime when record was last updated
     * @type {string}
     * @memberof EthereumAccountResponseDto
     */
    'updatedAt'?: string;
    /**
     * Message to be signed
     * @type {string}
     * @memberof EthereumAccountResponseDto
     */
    'verification_message': string;
    /**
     * Signed message
     * @type {string}
     * @memberof EthereumAccountResponseDto
     */
    'signed_message': string;
    /**
     * Whether signature has been verified
     * @type {boolean}
     * @memberof EthereumAccountResponseDto
     */
    'verified': boolean;
}
/**
 * 
 * @export
 * @interface EthereumAccountUpdateUserDto
 */
export interface EthereumAccountUpdateUserDto {
    /**
     * Governator user ID
     * @type {string}
     * @memberof EthereumAccountUpdateUserDto
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface LinkAccountDto
 */
export interface LinkAccountDto {
    /**
     * Provider ID - 
     * @type {string}
     * @memberof LinkAccountDto
     */
    'provider_id': string;
    /**
     * Signed message
     * @type {string}
     * @memberof LinkAccountDto
     */
    '_id': string;
}
/**
 * 
 * @export
 * @interface PollCreateDto
 */
export interface PollCreateDto {
    /**
     * Poll title
     * @type {string}
     * @memberof PollCreateDto
     */
    'title': string;
    /**
     * Client config for this poll
     * @type {Array<ClientConfigBase>}
     * @memberof PollCreateDto
     */
    'client_config': Array<ClientConfigBase>;
    /**
     * Array of strategy configs
     * @type {Array<StrategyConfigCreate>}
     * @memberof PollCreateDto
     */
    'strategy_config'?: Array<StrategyConfigCreate>;
    /**
     * Poll options object
     * @type {Array<PollOptionDto>}
     * @memberof PollCreateDto
     */
    'poll_options'?: Array<PollOptionDto>;
    /**
     * Whether anyone is allowed to add poll options
     * @type {boolean}
     * @memberof PollCreateDto
     */
    'allow_options_for_anyone'?: boolean;
    /**
     * Whether a person can vote multiple times
     * @type {boolean}
     * @memberof PollCreateDto
     */
    'single_vote'?: boolean;
    /**
     * Time the voting period ends
     * @type {string}
     * @memberof PollCreateDto
     */
    'end_time': string;
    /**
     * Poll description
     * @type {string}
     * @memberof PollCreateDto
     */
    'description': string;
    /**
     * Governator user ID of poll author
     * @type {string}
     * @memberof PollCreateDto
     */
    'author_user_id': string;
}
/**
 * 
 * @export
 * @interface PollOptionDto
 */
export interface PollOptionDto {
    /**
     * Poll option unique id
     * @type {string}
     * @memberof PollOptionDto
     */
    'poll_option_id': string;
    /**
     * Poll option id
     * @type {string}
     * @memberof PollOptionDto
     */
    'poll_option_name': string;
    /**
     * Poll option emoji
     * @type {string}
     * @memberof PollOptionDto
     */
    'poll_option_emoji': string;
}
/**
 * 
 * @export
 * @interface PollResponseDto
 */
export interface PollResponseDto {
    /**
     * Poll ID - (auto generated if left blank)
     * @type {string}
     * @memberof PollResponseDto
     */
    '_id'?: string;
    /**
     * Poll title
     * @type {string}
     * @memberof PollResponseDto
     */
    'title': string;
    /**
     * Client config for this poll
     * @type {Array<ClientConfigBase>}
     * @memberof PollResponseDto
     */
    'client_config': Array<ClientConfigBase>;
    /**
     * Array of strategy configs
     * @type {Array<StrategyConfig>}
     * @memberof PollResponseDto
     */
    'strategy_config'?: Array<StrategyConfig>;
    /**
     * Poll options object
     * @type {Array<PollOptionDto>}
     * @memberof PollResponseDto
     */
    'poll_options'?: Array<PollOptionDto>;
    /**
     * Whether anyone is allowed to add poll options
     * @type {boolean}
     * @memberof PollResponseDto
     */
    'allow_options_for_anyone'?: boolean;
    /**
     * Whether a person can vote multiple times
     * @type {boolean}
     * @memberof PollResponseDto
     */
    'single_vote'?: boolean;
    /**
     * Time the voting period ends
     * @type {string}
     * @memberof PollResponseDto
     */
    'end_time': string;
    /**
     * Poll description
     * @type {string}
     * @memberof PollResponseDto
     */
    'description': string;
    /**
     * Governator user ID of poll author
     * @type {string}
     * @memberof PollResponseDto
     */
    'author_user_id': string;
    /**
     * Datetime when record was created
     * @type {string}
     * @memberof PollResponseDto
     */
    'createdAt'?: string;
    /**
     * Datetime when record was last updated
     * @type {string}
     * @memberof PollResponseDto
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface PollUpdateDto
 */
export interface PollUpdateDto {
    /**
     * Poll title
     * @type {string}
     * @memberof PollUpdateDto
     */
    'title'?: string;
    /**
     * Client config for this poll
     * @type {Array<ClientConfigBase>}
     * @memberof PollUpdateDto
     */
    'client_config'?: Array<ClientConfigBase>;
    /**
     * Array of strategy configs
     * @type {Array<StrategyConfigCreate>}
     * @memberof PollUpdateDto
     */
    'strategy_config'?: Array<StrategyConfigCreate>;
    /**
     * Poll options object
     * @type {Array<PollOptionDto>}
     * @memberof PollUpdateDto
     */
    'poll_options'?: Array<PollOptionDto>;
    /**
     * Whether anyone is allowed to add poll options
     * @type {boolean}
     * @memberof PollUpdateDto
     */
    'allow_options_for_anyone'?: boolean;
    /**
     * Whether a person can vote multiple times
     * @type {boolean}
     * @memberof PollUpdateDto
     */
    'single_vote'?: boolean;
    /**
     * Time the voting period ends
     * @type {string}
     * @memberof PollUpdateDto
     */
    'end_time'?: string;
    /**
     * Poll description
     * @type {string}
     * @memberof PollUpdateDto
     */
    'description'?: string;
    /**
     * Governator user ID of poll author
     * @type {string}
     * @memberof PollUpdateDto
     */
    'author_user_id'?: string;
}
/**
 * 
 * @export
 * @interface SiweVerifyDto
 */
export interface SiweVerifyDto {
    /**
     * Ethereum account address
     * @type {string}
     * @memberof SiweVerifyDto
     */
    '_id': string;
    /**
     * Verification message
     * @type {string}
     * @memberof SiweVerifyDto
     */
    'verification_message': string;
    /**
     * Signed message
     * @type {string}
     * @memberof SiweVerifyDto
     */
    'signed_message': string;
    /**
     * 
     * @type {SiweVerifyDtoLinkAccount}
     * @memberof SiweVerifyDto
     */
    'link_account'?: SiweVerifyDtoLinkAccount;
}
/**
 * Account to be linked
 * @export
 * @interface SiweVerifyDtoLinkAccount
 */
export interface SiweVerifyDtoLinkAccount {
    /**
     * Provider ID - 
     * @type {string}
     * @memberof SiweVerifyDtoLinkAccount
     */
    'provider_id': string;
    /**
     * Signed message
     * @type {string}
     * @memberof SiweVerifyDtoLinkAccount
     */
    '_id': string;
}
/**
 * 
 * @export
 * @interface StrategyConfig
 */
export interface StrategyConfig {
    /**
     * Strategy type
     * @type {string}
     * @memberof StrategyConfig
     */
    'strategy_type': string;
    /**
     * Strategy id
     * @type {string}
     * @memberof StrategyConfig
     */
    'strategy_id': string;
    /**
     * Block height (block number or offset)
     * @type {number}
     * @memberof StrategyConfig
     */
    'block_height': number;
}
/**
 * 
 * @export
 * @interface StrategyConfigCreate
 */
export interface StrategyConfigCreate {
    /**
     * Strategy id
     * @type {string}
     * @memberof StrategyConfigCreate
     */
    'strategy_id': string;
    /**
     * Block height (block number or offset)
     * @type {number}
     * @memberof StrategyConfigCreate
     */
    'block_height': number;
    /**
     * Strategy type
     * @type {string}
     * @memberof StrategyConfigCreate
     */
    'strategy_type'?: string;
}
/**
 * 
 * @export
 * @interface StrategyRequestDto
 */
export interface StrategyRequestDto {
    /**
     * address to get voting power of
     * @type {string}
     * @memberof StrategyRequestDto
     */
    'account_id'?: string;
    /**
     * user to get voting power of
     * @type {number}
     * @memberof StrategyRequestDto
     */
    'block_height'?: number;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * ERC20 token contract address
     * @type {string}
     * @memberof Token
     */
    'contractAddress': string;
    /**
     * Chain Id
     * @type {number}
     * @memberof Token
     */
    'chain_id': number;
}
/**
 * 
 * @export
 * @interface TokenIdsDto
 */
export interface TokenIdsDto {
    /**
     * ERC721 token id
     * @type {number}
     * @memberof TokenIdsDto
     */
    'token_id': number;
}
/**
 * 
 * @export
 * @interface TokenList
 */
export interface TokenList {
    /**
     * Array of ERC20 tokens to query for balance
     * @type {Array<ERC20BalanceOfDto>}
     * @memberof TokenList
     */
    'tokens': Array<ERC20BalanceOfDto>;
}
/**
 * 
 * @export
 * @interface TokenMeta
 */
export interface TokenMeta {
    /**
     * Token Symbol
     * @type {string}
     * @memberof TokenMeta
     */
    'symbol'?: string;
    /**
     * Token Name
     * @type {string}
     * @memberof TokenMeta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TokenWhitelistCreateDto
 */
export interface TokenWhitelistCreateDto {
    /**
     * 
     * @type {TokenWhitelistResponseDtoId}
     * @memberof TokenWhitelistCreateDto
     */
    '_id': TokenWhitelistResponseDtoId;
    /**
     * Type of contract (ERC)
     * @type {number}
     * @memberof TokenWhitelistCreateDto
     */
    'erc': number;
}
/**
 * 
 * @export
 * @interface TokenWhitelistResponseDto
 */
export interface TokenWhitelistResponseDto {
    /**
     * 
     * @type {TokenWhitelistResponseDtoId}
     * @memberof TokenWhitelistResponseDto
     */
    '_id': TokenWhitelistResponseDtoId;
    /**
     * Type of contract (ERC)
     * @type {number}
     * @memberof TokenWhitelistResponseDto
     */
    'erc': number;
    /**
     * 
     * @type {TokenWhitelistResponseDtoMeta}
     * @memberof TokenWhitelistResponseDto
     */
    'meta'?: TokenWhitelistResponseDtoMeta;
    /**
     * Datetime when record was created
     * @type {string}
     * @memberof TokenWhitelistResponseDto
     */
    'createdAt'?: string;
    /**
     * Datetime when record was last updated
     * @type {string}
     * @memberof TokenWhitelistResponseDto
     */
    'updatedAt'?: string;
}
/**
 * Token
 * @export
 * @interface TokenWhitelistResponseDtoId
 */
export interface TokenWhitelistResponseDtoId {
    /**
     * ERC20 token contract address
     * @type {string}
     * @memberof TokenWhitelistResponseDtoId
     */
    'contractAddress': string;
    /**
     * Chain Id
     * @type {number}
     * @memberof TokenWhitelistResponseDtoId
     */
    'chain_id': number;
}
/**
 * Token Metadata
 * @export
 * @interface TokenWhitelistResponseDtoMeta
 */
export interface TokenWhitelistResponseDtoMeta {
    /**
     * Token Symbol
     * @type {string}
     * @memberof TokenWhitelistResponseDtoMeta
     */
    'symbol'?: string;
    /**
     * Token Name
     * @type {string}
     * @memberof TokenWhitelistResponseDtoMeta
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UserResponseDto
 */
export interface UserResponseDto {
    /**
     * Governator user id - (auto generated if left blank)
     * @type {string}
     * @memberof UserResponseDto
     */
    '_id'?: string;
    /**
     * Array of accounts
     * @type {Array<AccountBase>}
     * @memberof UserResponseDto
     */
    'provider_accounts'?: Array<AccountBase>;
    /**
     * Datetime when record was created
     * @type {string}
     * @memberof UserResponseDto
     */
    'createdAt'?: string;
    /**
     * Datetime when record was last updated
     * @type {string}
     * @memberof UserResponseDto
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface VoteRequestDto
 */
export interface VoteRequestDto {
    /**
     * Vote record object
     * @type {string}
     * @memberof VoteRequestDto
     */
    'poll_option_id': string;
    /**
     * account ID
     * @type {string}
     * @memberof VoteRequestDto
     */
    'account_id': string;
    /**
     * provider ID e.g. \"ethereum\" 
     * @type {string}
     * @memberof VoteRequestDto
     */
    'provider_id': string;
}
/**
 * 
 * @export
 * @interface VoteResponseDto
 */
export interface VoteResponseDto {
    /**
     * POST method used (create, update or delete)
     * @type {string}
     * @memberof VoteResponseDto
     */
    'method'?: string;
    /**
     * created/updated/deleted db object
     * @type {object}
     * @memberof VoteResponseDto
     */
    'data'?: object;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a discord account
         * @summary 
         * @param {DiscordAccountCreateDto} discordAccountCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerCheckAndCreateDiscordAccount: async (discordAccountCreateDto: DiscordAccountCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'discordAccountCreateDto' is not null or undefined
            assertParamExists('accountControllerCheckAndCreateDiscordAccount', 'discordAccountCreateDto', discordAccountCreateDto)
            const localVarPath = `/api/account/discord/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(discordAccountCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an unverified ethereum account
         * @summary 
         * @param {EthereumAccountCreateDto} ethereumAccountCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerCheckAndCreateEthereumAccount: async (ethereumAccountCreateDto: EthereumAccountCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ethereumAccountCreateDto' is not null or undefined
            assertParamExists('accountControllerCheckAndCreateEthereumAccount', 'ethereumAccountCreateDto', ethereumAccountCreateDto)
            const localVarPath = `/api/account/ethereum/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ethereumAccountCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a discord account
         * @summary 
         * @param {string} id Discord user Id
         * @param {DiscordAccountUpdateDto} discordAccountUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindByIdAndUpdateDiscordAccount: async (id: string, discordAccountUpdateDto: DiscordAccountUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountControllerFindByIdAndUpdateDiscordAccount', 'id', id)
            // verify required parameter 'discordAccountUpdateDto' is not null or undefined
            assertParamExists('accountControllerFindByIdAndUpdateDiscordAccount', 'discordAccountUpdateDto', discordAccountUpdateDto)
            const localVarPath = `/api/account/discord/update/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(discordAccountUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an ethereum account
         * @summary 
         * @param {string} id Ethereum address
         * @param {EthereumAccountUpdateUserDto} ethereumAccountUpdateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindByIdAndUpdateEthereumAccount: async (id: string, ethereumAccountUpdateUserDto: EthereumAccountUpdateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountControllerFindByIdAndUpdateEthereumAccount', 'id', id)
            // verify required parameter 'ethereumAccountUpdateUserDto' is not null or undefined
            assertParamExists('accountControllerFindByIdAndUpdateEthereumAccount', 'ethereumAccountUpdateUserDto', ethereumAccountUpdateUserDto)
            const localVarPath = `/api/account/ethereum/update/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ethereumAccountUpdateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Discord accounts
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindManyDiscordAccount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/account/discord/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Ethereum accounts
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindManyEthereumAccount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/account/ethereum/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a discord account
         * @summary 
         * @param {string} id Discord user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindOneAndDeleteDiscordAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountControllerFindOneAndDeleteDiscordAccount', 'id', id)
            const localVarPath = `/api/account/discord/delete/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an ethereum account
         * @summary 
         * @param {string} id Ethereum address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindOneAndDeleteEthereumAccount: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountControllerFindOneAndDeleteEthereumAccount', 'id', id)
            const localVarPath = `/api/account/ethereum/delete/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find a discord account
         * @summary 
         * @param {string} id Discord user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindOneDiscordAccountByProviderAccountId: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountControllerFindOneDiscordAccountByProviderAccountId', 'id', id)
            const localVarPath = `/api/account/discord/get-by-account-id/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find discord accounts by governator id
         * @summary 
         * @param {string} userId Governator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindOneDiscordAccountByUserId: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountControllerFindOneDiscordAccountByUserId', 'userId', userId)
            const localVarPath = `/api/account/discord/get-by-user-id/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find an ethereum account
         * @summary 
         * @param {string} id Ethereum address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindOneEthereumAccountByProviderAccountId: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountControllerFindOneEthereumAccountByProviderAccountId', 'id', id)
            const localVarPath = `/api/account/ethereum/get-by-account-id/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find Ethereum accounts
         * @summary 
         * @param {string} userId Governator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindOneEthereumAccountByUserId: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountControllerFindOneEthereumAccountByUserId', 'userId', userId)
            const localVarPath = `/api/account/ethereum/get-by-user-id/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a discord account
         * @summary 
         * @param {DiscordAccountCreateDto} discordAccountCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerCheckAndCreateDiscordAccount(discordAccountCreateDto: DiscordAccountCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordAccountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerCheckAndCreateDiscordAccount(discordAccountCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create an unverified ethereum account
         * @summary 
         * @param {EthereumAccountCreateDto} ethereumAccountCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerCheckAndCreateEthereumAccount(ethereumAccountCreateDto: EthereumAccountCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EthereumAccountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerCheckAndCreateEthereumAccount(ethereumAccountCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a discord account
         * @summary 
         * @param {string} id Discord user Id
         * @param {DiscordAccountUpdateDto} discordAccountUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerFindByIdAndUpdateDiscordAccount(id: string, discordAccountUpdateDto: DiscordAccountUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordAccountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerFindByIdAndUpdateDiscordAccount(id, discordAccountUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an ethereum account
         * @summary 
         * @param {string} id Ethereum address
         * @param {EthereumAccountUpdateUserDto} ethereumAccountUpdateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerFindByIdAndUpdateEthereumAccount(id: string, ethereumAccountUpdateUserDto: EthereumAccountUpdateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EthereumAccountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerFindByIdAndUpdateEthereumAccount(id, ethereumAccountUpdateUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all Discord accounts
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerFindManyDiscordAccount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DiscordAccountResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerFindManyDiscordAccount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all Ethereum accounts
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerFindManyEthereumAccount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EthereumAccountResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerFindManyEthereumAccount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a discord account
         * @summary 
         * @param {string} id Discord user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerFindOneAndDeleteDiscordAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordAccountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerFindOneAndDeleteDiscordAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an ethereum account
         * @summary 
         * @param {string} id Ethereum address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerFindOneAndDeleteEthereumAccount(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EthereumAccountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerFindOneAndDeleteEthereumAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find a discord account
         * @summary 
         * @param {string} id Discord user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerFindOneDiscordAccountByProviderAccountId(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordAccountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerFindOneDiscordAccountByProviderAccountId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find discord accounts by governator id
         * @summary 
         * @param {string} userId Governator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerFindOneDiscordAccountByUserId(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DiscordAccountResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerFindOneDiscordAccountByUserId(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find an ethereum account
         * @summary 
         * @param {string} id Ethereum address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerFindOneEthereumAccountByProviderAccountId(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EthereumAccountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerFindOneEthereumAccountByProviderAccountId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find Ethereum accounts
         * @summary 
         * @param {string} userId Governator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerFindOneEthereumAccountByUserId(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EthereumAccountResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerFindOneEthereumAccountByUserId(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * Create a discord account
         * @summary 
         * @param {DiscordAccountCreateDto} discordAccountCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerCheckAndCreateDiscordAccount(discordAccountCreateDto: DiscordAccountCreateDto, options?: any): AxiosPromise<DiscordAccountResponseDto> {
            return localVarFp.accountControllerCheckAndCreateDiscordAccount(discordAccountCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an unverified ethereum account
         * @summary 
         * @param {EthereumAccountCreateDto} ethereumAccountCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerCheckAndCreateEthereumAccount(ethereumAccountCreateDto: EthereumAccountCreateDto, options?: any): AxiosPromise<EthereumAccountResponseDto> {
            return localVarFp.accountControllerCheckAndCreateEthereumAccount(ethereumAccountCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a discord account
         * @summary 
         * @param {string} id Discord user Id
         * @param {DiscordAccountUpdateDto} discordAccountUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindByIdAndUpdateDiscordAccount(id: string, discordAccountUpdateDto: DiscordAccountUpdateDto, options?: any): AxiosPromise<DiscordAccountResponseDto> {
            return localVarFp.accountControllerFindByIdAndUpdateDiscordAccount(id, discordAccountUpdateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an ethereum account
         * @summary 
         * @param {string} id Ethereum address
         * @param {EthereumAccountUpdateUserDto} ethereumAccountUpdateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindByIdAndUpdateEthereumAccount(id: string, ethereumAccountUpdateUserDto: EthereumAccountUpdateUserDto, options?: any): AxiosPromise<EthereumAccountResponseDto> {
            return localVarFp.accountControllerFindByIdAndUpdateEthereumAccount(id, ethereumAccountUpdateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * List all Discord accounts
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindManyDiscordAccount(options?: any): AxiosPromise<Array<DiscordAccountResponseDto>> {
            return localVarFp.accountControllerFindManyDiscordAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * List all Ethereum accounts
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindManyEthereumAccount(options?: any): AxiosPromise<Array<EthereumAccountResponseDto>> {
            return localVarFp.accountControllerFindManyEthereumAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a discord account
         * @summary 
         * @param {string} id Discord user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindOneAndDeleteDiscordAccount(id: string, options?: any): AxiosPromise<DiscordAccountResponseDto> {
            return localVarFp.accountControllerFindOneAndDeleteDiscordAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an ethereum account
         * @summary 
         * @param {string} id Ethereum address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindOneAndDeleteEthereumAccount(id: string, options?: any): AxiosPromise<EthereumAccountResponseDto> {
            return localVarFp.accountControllerFindOneAndDeleteEthereumAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Find a discord account
         * @summary 
         * @param {string} id Discord user Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindOneDiscordAccountByProviderAccountId(id: string, options?: any): AxiosPromise<DiscordAccountResponseDto> {
            return localVarFp.accountControllerFindOneDiscordAccountByProviderAccountId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Find discord accounts by governator id
         * @summary 
         * @param {string} userId Governator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindOneDiscordAccountByUserId(userId: string, options?: any): AxiosPromise<Array<DiscordAccountResponseDto>> {
            return localVarFp.accountControllerFindOneDiscordAccountByUserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Find an ethereum account
         * @summary 
         * @param {string} id Ethereum address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindOneEthereumAccountByProviderAccountId(id: string, options?: any): AxiosPromise<EthereumAccountResponseDto> {
            return localVarFp.accountControllerFindOneEthereumAccountByProviderAccountId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Find Ethereum accounts
         * @summary 
         * @param {string} userId Governator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindOneEthereumAccountByUserId(userId: string, options?: any): AxiosPromise<Array<EthereumAccountResponseDto>> {
            return localVarFp.accountControllerFindOneEthereumAccountByUserId(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - interface
 * @export
 * @interface AccountApi
 */
export interface AccountApiInterface {
    /**
     * Create a discord account
     * @summary 
     * @param {DiscordAccountCreateDto} discordAccountCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerCheckAndCreateDiscordAccount(discordAccountCreateDto: DiscordAccountCreateDto, options?: AxiosRequestConfig): AxiosPromise<DiscordAccountResponseDto>;

    /**
     * Create an unverified ethereum account
     * @summary 
     * @param {EthereumAccountCreateDto} ethereumAccountCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerCheckAndCreateEthereumAccount(ethereumAccountCreateDto: EthereumAccountCreateDto, options?: AxiosRequestConfig): AxiosPromise<EthereumAccountResponseDto>;

    /**
     * Update a discord account
     * @summary 
     * @param {string} id Discord user Id
     * @param {DiscordAccountUpdateDto} discordAccountUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerFindByIdAndUpdateDiscordAccount(id: string, discordAccountUpdateDto: DiscordAccountUpdateDto, options?: AxiosRequestConfig): AxiosPromise<DiscordAccountResponseDto>;

    /**
     * Update an ethereum account
     * @summary 
     * @param {string} id Ethereum address
     * @param {EthereumAccountUpdateUserDto} ethereumAccountUpdateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerFindByIdAndUpdateEthereumAccount(id: string, ethereumAccountUpdateUserDto: EthereumAccountUpdateUserDto, options?: AxiosRequestConfig): AxiosPromise<EthereumAccountResponseDto>;

    /**
     * List all Discord accounts
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerFindManyDiscordAccount(options?: AxiosRequestConfig): AxiosPromise<Array<DiscordAccountResponseDto>>;

    /**
     * List all Ethereum accounts
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerFindManyEthereumAccount(options?: AxiosRequestConfig): AxiosPromise<Array<EthereumAccountResponseDto>>;

    /**
     * Delete a discord account
     * @summary 
     * @param {string} id Discord user Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerFindOneAndDeleteDiscordAccount(id: string, options?: AxiosRequestConfig): AxiosPromise<DiscordAccountResponseDto>;

    /**
     * Delete an ethereum account
     * @summary 
     * @param {string} id Ethereum address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerFindOneAndDeleteEthereumAccount(id: string, options?: AxiosRequestConfig): AxiosPromise<EthereumAccountResponseDto>;

    /**
     * Find a discord account
     * @summary 
     * @param {string} id Discord user Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerFindOneDiscordAccountByProviderAccountId(id: string, options?: AxiosRequestConfig): AxiosPromise<DiscordAccountResponseDto>;

    /**
     * Find discord accounts by governator id
     * @summary 
     * @param {string} userId Governator user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerFindOneDiscordAccountByUserId(userId: string, options?: AxiosRequestConfig): AxiosPromise<Array<DiscordAccountResponseDto>>;

    /**
     * Find an ethereum account
     * @summary 
     * @param {string} id Ethereum address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerFindOneEthereumAccountByProviderAccountId(id: string, options?: AxiosRequestConfig): AxiosPromise<EthereumAccountResponseDto>;

    /**
     * Find Ethereum accounts
     * @summary 
     * @param {string} userId Governator user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerFindOneEthereumAccountByUserId(userId: string, options?: AxiosRequestConfig): AxiosPromise<Array<EthereumAccountResponseDto>>;

}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI implements AccountApiInterface {
    /**
     * Create a discord account
     * @summary 
     * @param {DiscordAccountCreateDto} discordAccountCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerCheckAndCreateDiscordAccount(discordAccountCreateDto: DiscordAccountCreateDto, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerCheckAndCreateDiscordAccount(discordAccountCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an unverified ethereum account
     * @summary 
     * @param {EthereumAccountCreateDto} ethereumAccountCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerCheckAndCreateEthereumAccount(ethereumAccountCreateDto: EthereumAccountCreateDto, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerCheckAndCreateEthereumAccount(ethereumAccountCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a discord account
     * @summary 
     * @param {string} id Discord user Id
     * @param {DiscordAccountUpdateDto} discordAccountUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerFindByIdAndUpdateDiscordAccount(id: string, discordAccountUpdateDto: DiscordAccountUpdateDto, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerFindByIdAndUpdateDiscordAccount(id, discordAccountUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an ethereum account
     * @summary 
     * @param {string} id Ethereum address
     * @param {EthereumAccountUpdateUserDto} ethereumAccountUpdateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerFindByIdAndUpdateEthereumAccount(id: string, ethereumAccountUpdateUserDto: EthereumAccountUpdateUserDto, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerFindByIdAndUpdateEthereumAccount(id, ethereumAccountUpdateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all Discord accounts
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerFindManyDiscordAccount(options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerFindManyDiscordAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all Ethereum accounts
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerFindManyEthereumAccount(options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerFindManyEthereumAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a discord account
     * @summary 
     * @param {string} id Discord user Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerFindOneAndDeleteDiscordAccount(id: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerFindOneAndDeleteDiscordAccount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an ethereum account
     * @summary 
     * @param {string} id Ethereum address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerFindOneAndDeleteEthereumAccount(id: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerFindOneAndDeleteEthereumAccount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find a discord account
     * @summary 
     * @param {string} id Discord user Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerFindOneDiscordAccountByProviderAccountId(id: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerFindOneDiscordAccountByProviderAccountId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find discord accounts by governator id
     * @summary 
     * @param {string} userId Governator user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerFindOneDiscordAccountByUserId(userId: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerFindOneDiscordAccountByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find an ethereum account
     * @summary 
     * @param {string} id Ethereum address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerFindOneEthereumAccountByProviderAccountId(id: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerFindOneEthereumAccountByProviderAccountId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find Ethereum accounts
     * @summary 
     * @param {string} userId Governator user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerFindOneEthereumAccountByUserId(userId: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountControllerFindOneEthereumAccountByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CommunityApi - axios parameter creator
 * @export
 */
export const CommunityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new community
         * @summary 
         * @param {CommunityCreateDto} communityCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityControllerCreateCommunity: async (communityCreateDto: CommunityCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'communityCreateDto' is not null or undefined
            assertParamExists('communityControllerCreateCommunity', 'communityCreateDto', communityCreateDto)
            const localVarPath = `/api/community/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(communityCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} communityId ID of community to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityControllerDeleteCommunity: async (communityId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'communityId' is not null or undefined
            assertParamExists('communityControllerDeleteCommunity', 'communityId', communityId)
            const localVarPath = `/api/community/delete/{community_id}`
                .replace(`{${"community_id"}}`, encodeURIComponent(String(communityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch all communities
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityControllerFetchAllCommunities: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/community/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch community by Discord server ID
         * @summary 
         * @param {any} guildId Get community by Discord server ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityControllerFetchCommunityByDiscordGuildId: async (guildId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('communityControllerFetchCommunityByDiscordGuildId', 'guildId', guildId)
            const localVarPath = `/api/community/discord/{guild_id}`
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch community by ID
         * @summary 
         * @param {any} communityId Get community by ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityControllerFetchCommunityById: async (communityId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'communityId' is not null or undefined
            assertParamExists('communityControllerFetchCommunityById', 'communityId', communityId)
            const localVarPath = `/api/community/{community_id}`
                .replace(`{${"community_id"}}`, encodeURIComponent(String(communityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} communityId ID of community to be updated
         * @param {CommunityUpdateDto} communityUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityControllerUpdateCommunity: async (communityId: any, communityUpdateDto: CommunityUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'communityId' is not null or undefined
            assertParamExists('communityControllerUpdateCommunity', 'communityId', communityId)
            // verify required parameter 'communityUpdateDto' is not null or undefined
            assertParamExists('communityControllerUpdateCommunity', 'communityUpdateDto', communityUpdateDto)
            const localVarPath = `/api/community/update/{community_id}`
                .replace(`{${"community_id"}}`, encodeURIComponent(String(communityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(communityUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommunityApi - functional programming interface
 * @export
 */
export const CommunityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommunityApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new community
         * @summary 
         * @param {CommunityCreateDto} communityCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async communityControllerCreateCommunity(communityCreateDto: CommunityCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommunityResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.communityControllerCreateCommunity(communityCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} communityId ID of community to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async communityControllerDeleteCommunity(communityId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommunityResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.communityControllerDeleteCommunity(communityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch all communities
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async communityControllerFetchAllCommunities(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommunityResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.communityControllerFetchAllCommunities(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch community by Discord server ID
         * @summary 
         * @param {any} guildId Get community by Discord server ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async communityControllerFetchCommunityByDiscordGuildId(guildId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommunityResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.communityControllerFetchCommunityByDiscordGuildId(guildId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch community by ID
         * @summary 
         * @param {any} communityId Get community by ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async communityControllerFetchCommunityById(communityId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommunityResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.communityControllerFetchCommunityById(communityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} communityId ID of community to be updated
         * @param {CommunityUpdateDto} communityUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async communityControllerUpdateCommunity(communityId: any, communityUpdateDto: CommunityUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommunityResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.communityControllerUpdateCommunity(communityId, communityUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommunityApi - factory interface
 * @export
 */
export const CommunityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommunityApiFp(configuration)
    return {
        /**
         * Create a new community
         * @summary 
         * @param {CommunityCreateDto} communityCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityControllerCreateCommunity(communityCreateDto: CommunityCreateDto, options?: any): AxiosPromise<CommunityResponseDto> {
            return localVarFp.communityControllerCreateCommunity(communityCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} communityId ID of community to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityControllerDeleteCommunity(communityId: any, options?: any): AxiosPromise<CommunityResponseDto> {
            return localVarFp.communityControllerDeleteCommunity(communityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all communities
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityControllerFetchAllCommunities(options?: any): AxiosPromise<Array<CommunityResponseDto>> {
            return localVarFp.communityControllerFetchAllCommunities(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch community by Discord server ID
         * @summary 
         * @param {any} guildId Get community by Discord server ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityControllerFetchCommunityByDiscordGuildId(guildId: any, options?: any): AxiosPromise<CommunityResponseDto> {
            return localVarFp.communityControllerFetchCommunityByDiscordGuildId(guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch community by ID
         * @summary 
         * @param {any} communityId Get community by ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityControllerFetchCommunityById(communityId: any, options?: any): AxiosPromise<CommunityResponseDto> {
            return localVarFp.communityControllerFetchCommunityById(communityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} communityId ID of community to be updated
         * @param {CommunityUpdateDto} communityUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityControllerUpdateCommunity(communityId: any, communityUpdateDto: CommunityUpdateDto, options?: any): AxiosPromise<CommunityResponseDto> {
            return localVarFp.communityControllerUpdateCommunity(communityId, communityUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommunityApi - interface
 * @export
 * @interface CommunityApi
 */
export interface CommunityApiInterface {
    /**
     * Create a new community
     * @summary 
     * @param {CommunityCreateDto} communityCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityApiInterface
     */
    communityControllerCreateCommunity(communityCreateDto: CommunityCreateDto, options?: AxiosRequestConfig): AxiosPromise<CommunityResponseDto>;

    /**
     * 
     * @param {any} communityId ID of community to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityApiInterface
     */
    communityControllerDeleteCommunity(communityId: any, options?: AxiosRequestConfig): AxiosPromise<CommunityResponseDto>;

    /**
     * Fetch all communities
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityApiInterface
     */
    communityControllerFetchAllCommunities(options?: AxiosRequestConfig): AxiosPromise<Array<CommunityResponseDto>>;

    /**
     * Fetch community by Discord server ID
     * @summary 
     * @param {any} guildId Get community by Discord server ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityApiInterface
     */
    communityControllerFetchCommunityByDiscordGuildId(guildId: any, options?: AxiosRequestConfig): AxiosPromise<CommunityResponseDto>;

    /**
     * Fetch community by ID
     * @summary 
     * @param {any} communityId Get community by ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityApiInterface
     */
    communityControllerFetchCommunityById(communityId: any, options?: AxiosRequestConfig): AxiosPromise<CommunityResponseDto>;

    /**
     * 
     * @param {any} communityId ID of community to be updated
     * @param {CommunityUpdateDto} communityUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityApiInterface
     */
    communityControllerUpdateCommunity(communityId: any, communityUpdateDto: CommunityUpdateDto, options?: AxiosRequestConfig): AxiosPromise<CommunityResponseDto>;

}

/**
 * CommunityApi - object-oriented interface
 * @export
 * @class CommunityApi
 * @extends {BaseAPI}
 */
export class CommunityApi extends BaseAPI implements CommunityApiInterface {
    /**
     * Create a new community
     * @summary 
     * @param {CommunityCreateDto} communityCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityApi
     */
    public communityControllerCreateCommunity(communityCreateDto: CommunityCreateDto, options?: AxiosRequestConfig) {
        return CommunityApiFp(this.configuration).communityControllerCreateCommunity(communityCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {any} communityId ID of community to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityApi
     */
    public communityControllerDeleteCommunity(communityId: any, options?: AxiosRequestConfig) {
        return CommunityApiFp(this.configuration).communityControllerDeleteCommunity(communityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch all communities
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityApi
     */
    public communityControllerFetchAllCommunities(options?: AxiosRequestConfig) {
        return CommunityApiFp(this.configuration).communityControllerFetchAllCommunities(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch community by Discord server ID
     * @summary 
     * @param {any} guildId Get community by Discord server ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityApi
     */
    public communityControllerFetchCommunityByDiscordGuildId(guildId: any, options?: AxiosRequestConfig) {
        return CommunityApiFp(this.configuration).communityControllerFetchCommunityByDiscordGuildId(guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch community by ID
     * @summary 
     * @param {any} communityId Get community by ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityApi
     */
    public communityControllerFetchCommunityById(communityId: any, options?: AxiosRequestConfig) {
        return CommunityApiFp(this.configuration).communityControllerFetchCommunityById(communityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {any} communityId ID of community to be updated
     * @param {CommunityUpdateDto} communityUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunityApi
     */
    public communityControllerUpdateCommunity(communityId: any, communityUpdateDto: CommunityUpdateDto, options?: AxiosRequestConfig) {
        return CommunityApiFp(this.configuration).communityControllerUpdateCommunity(communityId, communityUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PollApi - axios parameter creator
 * @export
 */
export const PollApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new poll
         * @summary 
         * @param {PollCreateDto} pollCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollControllerCreatePoll: async (pollCreateDto: PollCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pollCreateDto' is not null or undefined
            assertParamExists('pollControllerCreatePoll', 'pollCreateDto', pollCreateDto)
            const localVarPath = `/api/poll/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pollCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} pollId ID of poll to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollControllerDeletePoll: async (pollId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pollId' is not null or undefined
            assertParamExists('pollControllerDeletePoll', 'pollId', pollId)
            const localVarPath = `/api/poll/delete/{poll_id}`
                .replace(`{${"poll_id"}}`, encodeURIComponent(String(pollId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch all polls
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollControllerFetchAllPolls: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/poll/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch poll by ID
         * @summary 
         * @param {any} pollId Get poll by ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollControllerFetchPollById: async (pollId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pollId' is not null or undefined
            assertParamExists('pollControllerFetchPollById', 'pollId', pollId)
            const localVarPath = `/api/poll/{poll_id}`
                .replace(`{${"poll_id"}}`, encodeURIComponent(String(pollId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch polls by author
         * @summary 
         * @param {any} authorUserId Governator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollControllerFetchPollByUser: async (authorUserId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorUserId' is not null or undefined
            assertParamExists('pollControllerFetchPollByUser', 'authorUserId', authorUserId)
            const localVarPath = `/api/poll/user/{author_user_id}`
                .replace(`{${"author_user_id"}}`, encodeURIComponent(String(authorUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch active polls by author
         * @summary 
         * @param {any} authorUserId Governator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollControllerFetchPollByUserOngoing: async (authorUserId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorUserId' is not null or undefined
            assertParamExists('pollControllerFetchPollByUserOngoing', 'authorUserId', authorUserId)
            const localVarPath = `/api/poll/user/{author_user_id}/active`
                .replace(`{${"author_user_id"}}`, encodeURIComponent(String(authorUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} pollId ID of poll to be updated
         * @param {PollUpdateDto} pollUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollControllerUpdatePoll: async (pollId: any, pollUpdateDto: PollUpdateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pollId' is not null or undefined
            assertParamExists('pollControllerUpdatePoll', 'pollId', pollId)
            // verify required parameter 'pollUpdateDto' is not null or undefined
            assertParamExists('pollControllerUpdatePoll', 'pollUpdateDto', pollUpdateDto)
            const localVarPath = `/api/poll/update/{poll_id}`
                .replace(`{${"poll_id"}}`, encodeURIComponent(String(pollId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pollUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PollApi - functional programming interface
 * @export
 */
export const PollApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PollApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new poll
         * @summary 
         * @param {PollCreateDto} pollCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollControllerCreatePoll(pollCreateDto: PollCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PollResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pollControllerCreatePoll(pollCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} pollId ID of poll to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollControllerDeletePoll(pollId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PollResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pollControllerDeletePoll(pollId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch all polls
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollControllerFetchAllPolls(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PollResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pollControllerFetchAllPolls(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch poll by ID
         * @summary 
         * @param {any} pollId Get poll by ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollControllerFetchPollById(pollId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PollResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pollControllerFetchPollById(pollId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch polls by author
         * @summary 
         * @param {any} authorUserId Governator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollControllerFetchPollByUser(authorUserId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PollResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pollControllerFetchPollByUser(authorUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch active polls by author
         * @summary 
         * @param {any} authorUserId Governator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollControllerFetchPollByUserOngoing(authorUserId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PollResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pollControllerFetchPollByUserOngoing(authorUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} pollId ID of poll to be updated
         * @param {PollUpdateDto} pollUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pollControllerUpdatePoll(pollId: any, pollUpdateDto: PollUpdateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PollResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pollControllerUpdatePoll(pollId, pollUpdateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PollApi - factory interface
 * @export
 */
export const PollApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PollApiFp(configuration)
    return {
        /**
         * Create a new poll
         * @summary 
         * @param {PollCreateDto} pollCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollControllerCreatePoll(pollCreateDto: PollCreateDto, options?: any): AxiosPromise<PollResponseDto> {
            return localVarFp.pollControllerCreatePoll(pollCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} pollId ID of poll to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollControllerDeletePoll(pollId: any, options?: any): AxiosPromise<PollResponseDto> {
            return localVarFp.pollControllerDeletePoll(pollId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all polls
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollControllerFetchAllPolls(options?: any): AxiosPromise<Array<PollResponseDto>> {
            return localVarFp.pollControllerFetchAllPolls(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch poll by ID
         * @summary 
         * @param {any} pollId Get poll by ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollControllerFetchPollById(pollId: any, options?: any): AxiosPromise<PollResponseDto> {
            return localVarFp.pollControllerFetchPollById(pollId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch polls by author
         * @summary 
         * @param {any} authorUserId Governator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollControllerFetchPollByUser(authorUserId: any, options?: any): AxiosPromise<Array<PollResponseDto>> {
            return localVarFp.pollControllerFetchPollByUser(authorUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch active polls by author
         * @summary 
         * @param {any} authorUserId Governator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollControllerFetchPollByUserOngoing(authorUserId: any, options?: any): AxiosPromise<Array<PollResponseDto>> {
            return localVarFp.pollControllerFetchPollByUserOngoing(authorUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} pollId ID of poll to be updated
         * @param {PollUpdateDto} pollUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pollControllerUpdatePoll(pollId: any, pollUpdateDto: PollUpdateDto, options?: any): AxiosPromise<PollResponseDto> {
            return localVarFp.pollControllerUpdatePoll(pollId, pollUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PollApi - interface
 * @export
 * @interface PollApi
 */
export interface PollApiInterface {
    /**
     * Create a new poll
     * @summary 
     * @param {PollCreateDto} pollCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApiInterface
     */
    pollControllerCreatePoll(pollCreateDto: PollCreateDto, options?: AxiosRequestConfig): AxiosPromise<PollResponseDto>;

    /**
     * 
     * @param {any} pollId ID of poll to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApiInterface
     */
    pollControllerDeletePoll(pollId: any, options?: AxiosRequestConfig): AxiosPromise<PollResponseDto>;

    /**
     * Fetch all polls
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApiInterface
     */
    pollControllerFetchAllPolls(options?: AxiosRequestConfig): AxiosPromise<Array<PollResponseDto>>;

    /**
     * Fetch poll by ID
     * @summary 
     * @param {any} pollId Get poll by ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApiInterface
     */
    pollControllerFetchPollById(pollId: any, options?: AxiosRequestConfig): AxiosPromise<PollResponseDto>;

    /**
     * Fetch polls by author
     * @summary 
     * @param {any} authorUserId Governator user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApiInterface
     */
    pollControllerFetchPollByUser(authorUserId: any, options?: AxiosRequestConfig): AxiosPromise<Array<PollResponseDto>>;

    /**
     * Fetch active polls by author
     * @summary 
     * @param {any} authorUserId Governator user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApiInterface
     */
    pollControllerFetchPollByUserOngoing(authorUserId: any, options?: AxiosRequestConfig): AxiosPromise<Array<PollResponseDto>>;

    /**
     * 
     * @param {any} pollId ID of poll to be updated
     * @param {PollUpdateDto} pollUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApiInterface
     */
    pollControllerUpdatePoll(pollId: any, pollUpdateDto: PollUpdateDto, options?: AxiosRequestConfig): AxiosPromise<PollResponseDto>;

}

/**
 * PollApi - object-oriented interface
 * @export
 * @class PollApi
 * @extends {BaseAPI}
 */
export class PollApi extends BaseAPI implements PollApiInterface {
    /**
     * Create a new poll
     * @summary 
     * @param {PollCreateDto} pollCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApi
     */
    public pollControllerCreatePoll(pollCreateDto: PollCreateDto, options?: AxiosRequestConfig) {
        return PollApiFp(this.configuration).pollControllerCreatePoll(pollCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {any} pollId ID of poll to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApi
     */
    public pollControllerDeletePoll(pollId: any, options?: AxiosRequestConfig) {
        return PollApiFp(this.configuration).pollControllerDeletePoll(pollId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch all polls
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApi
     */
    public pollControllerFetchAllPolls(options?: AxiosRequestConfig) {
        return PollApiFp(this.configuration).pollControllerFetchAllPolls(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch poll by ID
     * @summary 
     * @param {any} pollId Get poll by ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApi
     */
    public pollControllerFetchPollById(pollId: any, options?: AxiosRequestConfig) {
        return PollApiFp(this.configuration).pollControllerFetchPollById(pollId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch polls by author
     * @summary 
     * @param {any} authorUserId Governator user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApi
     */
    public pollControllerFetchPollByUser(authorUserId: any, options?: AxiosRequestConfig) {
        return PollApiFp(this.configuration).pollControllerFetchPollByUser(authorUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch active polls by author
     * @summary 
     * @param {any} authorUserId Governator user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApi
     */
    public pollControllerFetchPollByUserOngoing(authorUserId: any, options?: AxiosRequestConfig) {
        return PollApiFp(this.configuration).pollControllerFetchPollByUserOngoing(authorUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {any} pollId ID of poll to be updated
     * @param {PollUpdateDto} pollUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PollApi
     */
    public pollControllerUpdatePoll(pollId: any, pollUpdateDto: PollUpdateDto, options?: AxiosRequestConfig) {
        return PollApiFp(this.configuration).pollControllerUpdatePoll(pollId, pollUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RequestDataFromClientApi - axios parameter creator
 * @export
 */
export const RequestDataFromClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Request data from client
         * @summary 
         * @param {string} discordUserId discord user id requesting the data
         * @param {'channels' | 'roles'} datasource data set you want to request
         * @param {string} guildId discord guild (&#x3D;server) ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRequestControllerSendRequest: async (discordUserId: string, datasource: 'channels' | 'roles', guildId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'discordUserId' is not null or undefined
            assertParamExists('clientRequestControllerSendRequest', 'discordUserId', discordUserId)
            // verify required parameter 'datasource' is not null or undefined
            assertParamExists('clientRequestControllerSendRequest', 'datasource', datasource)
            // verify required parameter 'guildId' is not null or undefined
            assertParamExists('clientRequestControllerSendRequest', 'guildId', guildId)
            const localVarPath = `/api/client/discord/{guild_id}/{datasource}/{discord_user_id}`
                .replace(`{${"discord_user_id"}}`, encodeURIComponent(String(discordUserId)))
                .replace(`{${"datasource"}}`, encodeURIComponent(String(datasource)))
                .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Client can submit requested data to this endpoint
         * @summary 
         * @param {DiscordResponseDto} discordResponseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRequestControllerSendResponse: async (discordResponseDto: DiscordResponseDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'discordResponseDto' is not null or undefined
            assertParamExists('clientRequestControllerSendResponse', 'discordResponseDto', discordResponseDto)
            const localVarPath = `/api/client/discord/data-response`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(discordResponseDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequestDataFromClientApi - functional programming interface
 * @export
 */
export const RequestDataFromClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RequestDataFromClientApiAxiosParamCreator(configuration)
    return {
        /**
         * Request data from client
         * @summary 
         * @param {string} discordUserId discord user id requesting the data
         * @param {'channels' | 'roles'} datasource data set you want to request
         * @param {string} guildId discord guild (&#x3D;server) ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientRequestControllerSendRequest(discordUserId: string, datasource: 'channels' | 'roles', guildId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientRequestControllerSendRequest(discordUserId, datasource, guildId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Client can submit requested data to this endpoint
         * @summary 
         * @param {DiscordResponseDto} discordResponseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientRequestControllerSendResponse(discordResponseDto: DiscordResponseDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientRequestControllerSendResponse(discordResponseDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RequestDataFromClientApi - factory interface
 * @export
 */
export const RequestDataFromClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RequestDataFromClientApiFp(configuration)
    return {
        /**
         * Request data from client
         * @summary 
         * @param {string} discordUserId discord user id requesting the data
         * @param {'channels' | 'roles'} datasource data set you want to request
         * @param {string} guildId discord guild (&#x3D;server) ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRequestControllerSendRequest(discordUserId: string, datasource: 'channels' | 'roles', guildId: string, options?: any): AxiosPromise<DiscordResponseDto> {
            return localVarFp.clientRequestControllerSendRequest(discordUserId, datasource, guildId, options).then((request) => request(axios, basePath));
        },
        /**
         * Client can submit requested data to this endpoint
         * @summary 
         * @param {DiscordResponseDto} discordResponseDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientRequestControllerSendResponse(discordResponseDto: DiscordResponseDto, options?: any): AxiosPromise<void> {
            return localVarFp.clientRequestControllerSendResponse(discordResponseDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RequestDataFromClientApi - interface
 * @export
 * @interface RequestDataFromClientApi
 */
export interface RequestDataFromClientApiInterface {
    /**
     * Request data from client
     * @summary 
     * @param {string} discordUserId discord user id requesting the data
     * @param {'channels' | 'roles'} datasource data set you want to request
     * @param {string} guildId discord guild (&#x3D;server) ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestDataFromClientApiInterface
     */
    clientRequestControllerSendRequest(discordUserId: string, datasource: 'channels' | 'roles', guildId: string, options?: AxiosRequestConfig): AxiosPromise<DiscordResponseDto>;

    /**
     * Client can submit requested data to this endpoint
     * @summary 
     * @param {DiscordResponseDto} discordResponseDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestDataFromClientApiInterface
     */
    clientRequestControllerSendResponse(discordResponseDto: DiscordResponseDto, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * RequestDataFromClientApi - object-oriented interface
 * @export
 * @class RequestDataFromClientApi
 * @extends {BaseAPI}
 */
export class RequestDataFromClientApi extends BaseAPI implements RequestDataFromClientApiInterface {
    /**
     * Request data from client
     * @summary 
     * @param {string} discordUserId discord user id requesting the data
     * @param {'channels' | 'roles'} datasource data set you want to request
     * @param {string} guildId discord guild (&#x3D;server) ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestDataFromClientApi
     */
    public clientRequestControllerSendRequest(discordUserId: string, datasource: 'channels' | 'roles', guildId: string, options?: AxiosRequestConfig) {
        return RequestDataFromClientApiFp(this.configuration).clientRequestControllerSendRequest(discordUserId, datasource, guildId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Client can submit requested data to this endpoint
     * @summary 
     * @param {DiscordResponseDto} discordResponseDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequestDataFromClientApi
     */
    public clientRequestControllerSendResponse(discordResponseDto: DiscordResponseDto, options?: AxiosRequestConfig) {
        return RequestDataFromClientApiFp(this.configuration).clientRequestControllerSendResponse(discordResponseDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerSentEventsApi - axios parameter creator
 * @export
 */
export const ServerSentEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Publishes an event to the event stream
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sseControllerPublish: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sse/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sseControllerStream: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerSentEventsApi - functional programming interface
 * @export
 */
export const ServerSentEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerSentEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Publishes an event to the event stream
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sseControllerPublish(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sseControllerPublish(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sseControllerStream(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sseControllerStream(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerSentEventsApi - factory interface
 * @export
 */
export const ServerSentEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerSentEventsApiFp(configuration)
    return {
        /**
         * Publishes an event to the event stream
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sseControllerPublish(options?: any): AxiosPromise<void> {
            return localVarFp.sseControllerPublish(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sseControllerStream(options?: any): AxiosPromise<void> {
            return localVarFp.sseControllerStream(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerSentEventsApi - interface
 * @export
 * @interface ServerSentEventsApi
 */
export interface ServerSentEventsApiInterface {
    /**
     * Publishes an event to the event stream
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSentEventsApiInterface
     */
    sseControllerPublish(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSentEventsApiInterface
     */
    sseControllerStream(options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * ServerSentEventsApi - object-oriented interface
 * @export
 * @class ServerSentEventsApi
 * @extends {BaseAPI}
 */
export class ServerSentEventsApi extends BaseAPI implements ServerSentEventsApiInterface {
    /**
     * Publishes an event to the event stream
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSentEventsApi
     */
    public sseControllerPublish(options?: AxiosRequestConfig) {
        return ServerSentEventsApiFp(this.configuration).sseControllerPublish(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerSentEventsApi
     */
    public sseControllerStream(options?: AxiosRequestConfig) {
        return ServerSentEventsApiFp(this.configuration).sseControllerStream(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StrategiesApi - axios parameter creator
 * @export
 */
export const StrategiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * BANK - Token Weighted
         * @summary 
         * @param {StrategyRequestDto} strategyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTokenWeightedStrategyPost: async (strategyRequestDto: StrategyRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strategyRequestDto' is not null or undefined
            assertParamExists('bankTokenWeightedStrategyPost', 'strategyRequestDto', strategyRequestDto)
            const localVarPath = `/api/strategies/bank-token-weighted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(strategyRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} id Strategy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        daoPunksStrategyGet: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('daoPunksStrategyGet', 'id', id)
            const localVarPath = `/api/strategies/find/one/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        daoPunksStrategyGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/strategies/find/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DAOPUNKS - ERC721 Weighted
         * @summary 
         * @param {StrategyRequestDto} strategyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        daoPunksStrategyPost: async (strategyRequestDto: StrategyRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strategyRequestDto' is not null or undefined
            assertParamExists('daoPunksStrategyPost', 'strategyRequestDto', strategyRequestDto)
            const localVarPath = `/api/strategies/daopunks-e-r-c-721-weighted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(strategyRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Standard (1 Vote = 1 Vote)
         * @summary 
         * @param {StrategyRequestDto} strategyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        noneStrategyPost: async (strategyRequestDto: StrategyRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strategyRequestDto' is not null or undefined
            assertParamExists('noneStrategyPost', 'strategyRequestDto', strategyRequestDto)
            const localVarPath = `/api/strategies/standard-1-vote-1-vote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(strategyRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POOLY - ERC721 Weighted
         * @summary 
         * @param {StrategyRequestDto} strategyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolyErc721WeightedStrategyPost: async (strategyRequestDto: StrategyRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'strategyRequestDto' is not null or undefined
            assertParamExists('poolyErc721WeightedStrategyPost', 'strategyRequestDto', strategyRequestDto)
            const localVarPath = `/api/strategies/pooly-e-r-c-721-weighted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(strategyRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StrategiesApi - functional programming interface
 * @export
 */
export const StrategiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StrategiesApiAxiosParamCreator(configuration)
    return {
        /**
         * BANK - Token Weighted
         * @summary 
         * @param {StrategyRequestDto} strategyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTokenWeightedStrategyPost(strategyRequestDto: StrategyRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTokenWeightedStrategyPost(strategyRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} id Strategy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async daoPunksStrategyGet(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.daoPunksStrategyGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async daoPunksStrategyGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.daoPunksStrategyGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DAOPUNKS - ERC721 Weighted
         * @summary 
         * @param {StrategyRequestDto} strategyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async daoPunksStrategyPost(strategyRequestDto: StrategyRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.daoPunksStrategyPost(strategyRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Standard (1 Vote = 1 Vote)
         * @summary 
         * @param {StrategyRequestDto} strategyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async noneStrategyPost(strategyRequestDto: StrategyRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.noneStrategyPost(strategyRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * POOLY - ERC721 Weighted
         * @summary 
         * @param {StrategyRequestDto} strategyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async poolyErc721WeightedStrategyPost(strategyRequestDto: StrategyRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.poolyErc721WeightedStrategyPost(strategyRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StrategiesApi - factory interface
 * @export
 */
export const StrategiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StrategiesApiFp(configuration)
    return {
        /**
         * BANK - Token Weighted
         * @summary 
         * @param {StrategyRequestDto} strategyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTokenWeightedStrategyPost(strategyRequestDto: StrategyRequestDto, options?: any): AxiosPromise<string> {
            return localVarFp.bankTokenWeightedStrategyPost(strategyRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} id Strategy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        daoPunksStrategyGet(id: any, options?: any): AxiosPromise<object> {
            return localVarFp.daoPunksStrategyGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        daoPunksStrategyGetAll(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.daoPunksStrategyGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * DAOPUNKS - ERC721 Weighted
         * @summary 
         * @param {StrategyRequestDto} strategyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        daoPunksStrategyPost(strategyRequestDto: StrategyRequestDto, options?: any): AxiosPromise<string> {
            return localVarFp.daoPunksStrategyPost(strategyRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Standard (1 Vote = 1 Vote)
         * @summary 
         * @param {StrategyRequestDto} strategyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        noneStrategyPost(strategyRequestDto: StrategyRequestDto, options?: any): AxiosPromise<string> {
            return localVarFp.noneStrategyPost(strategyRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * POOLY - ERC721 Weighted
         * @summary 
         * @param {StrategyRequestDto} strategyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        poolyErc721WeightedStrategyPost(strategyRequestDto: StrategyRequestDto, options?: any): AxiosPromise<string> {
            return localVarFp.poolyErc721WeightedStrategyPost(strategyRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StrategiesApi - interface
 * @export
 * @interface StrategiesApi
 */
export interface StrategiesApiInterface {
    /**
     * BANK - Token Weighted
     * @summary 
     * @param {StrategyRequestDto} strategyRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApiInterface
     */
    bankTokenWeightedStrategyPost(strategyRequestDto: StrategyRequestDto, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @param {any} id Strategy ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApiInterface
     */
    daoPunksStrategyGet(id: any, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApiInterface
     */
    daoPunksStrategyGetAll(options?: AxiosRequestConfig): AxiosPromise<Array<object>>;

    /**
     * DAOPUNKS - ERC721 Weighted
     * @summary 
     * @param {StrategyRequestDto} strategyRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApiInterface
     */
    daoPunksStrategyPost(strategyRequestDto: StrategyRequestDto, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * Standard (1 Vote = 1 Vote)
     * @summary 
     * @param {StrategyRequestDto} strategyRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApiInterface
     */
    noneStrategyPost(strategyRequestDto: StrategyRequestDto, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * POOLY - ERC721 Weighted
     * @summary 
     * @param {StrategyRequestDto} strategyRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApiInterface
     */
    poolyErc721WeightedStrategyPost(strategyRequestDto: StrategyRequestDto, options?: AxiosRequestConfig): AxiosPromise<string>;

}

/**
 * StrategiesApi - object-oriented interface
 * @export
 * @class StrategiesApi
 * @extends {BaseAPI}
 */
export class StrategiesApi extends BaseAPI implements StrategiesApiInterface {
    /**
     * BANK - Token Weighted
     * @summary 
     * @param {StrategyRequestDto} strategyRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApi
     */
    public bankTokenWeightedStrategyPost(strategyRequestDto: StrategyRequestDto, options?: AxiosRequestConfig) {
        return StrategiesApiFp(this.configuration).bankTokenWeightedStrategyPost(strategyRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {any} id Strategy ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApi
     */
    public daoPunksStrategyGet(id: any, options?: AxiosRequestConfig) {
        return StrategiesApiFp(this.configuration).daoPunksStrategyGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApi
     */
    public daoPunksStrategyGetAll(options?: AxiosRequestConfig) {
        return StrategiesApiFp(this.configuration).daoPunksStrategyGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DAOPUNKS - ERC721 Weighted
     * @summary 
     * @param {StrategyRequestDto} strategyRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApi
     */
    public daoPunksStrategyPost(strategyRequestDto: StrategyRequestDto, options?: AxiosRequestConfig) {
        return StrategiesApiFp(this.configuration).daoPunksStrategyPost(strategyRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Standard (1 Vote = 1 Vote)
     * @summary 
     * @param {StrategyRequestDto} strategyRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApi
     */
    public noneStrategyPost(strategyRequestDto: StrategyRequestDto, options?: AxiosRequestConfig) {
        return StrategiesApiFp(this.configuration).noneStrategyPost(strategyRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POOLY - ERC721 Weighted
     * @summary 
     * @param {StrategyRequestDto} strategyRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StrategiesApi
     */
    public poolyErc721WeightedStrategyPost(strategyRequestDto: StrategyRequestDto, options?: AxiosRequestConfig) {
        return StrategiesApiFp(this.configuration).poolyErc721WeightedStrategyPost(strategyRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch all users
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFetchAllUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch user by ID
         * @summary 
         * @param {any} userId Get user by ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFetchUserById: async (userId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userControllerFetchUserById', 'userId', userId)
            const localVarPath = `/api/user/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch user by account
         * @summary 
         * @param {any} accountId Account ID, e.g. discord user ID
         * @param {'discord' | 'ethereum'} providerId ID of account provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFetchUserByProvider: async (accountId: any, providerId: 'discord' | 'ethereum', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('userControllerFetchUserByProvider', 'accountId', accountId)
            // verify required parameter 'providerId' is not null or undefined
            assertParamExists('userControllerFetchUserByProvider', 'providerId', providerId)
            const localVarPath = `/api/user/{provider_id}/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"provider_id"}}`, encodeURIComponent(String(providerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetch all users
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFetchAllUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFetchAllUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch user by ID
         * @summary 
         * @param {any} userId Get user by ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFetchUserById(userId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFetchUserById(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch user by account
         * @summary 
         * @param {any} accountId Account ID, e.g. discord user ID
         * @param {'discord' | 'ethereum'} providerId ID of account provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerFetchUserByProvider(accountId: any, providerId: 'discord' | 'ethereum', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerFetchUserByProvider(accountId, providerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Fetch all users
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFetchAllUsers(options?: any): AxiosPromise<Array<UserResponseDto>> {
            return localVarFp.userControllerFetchAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch user by ID
         * @summary 
         * @param {any} userId Get user by ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFetchUserById(userId: any, options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.userControllerFetchUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch user by account
         * @summary 
         * @param {any} accountId Account ID, e.g. discord user ID
         * @param {'discord' | 'ethereum'} providerId ID of account provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerFetchUserByProvider(accountId: any, providerId: 'discord' | 'ethereum', options?: any): AxiosPromise<UserResponseDto> {
            return localVarFp.userControllerFetchUserByProvider(accountId, providerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * Fetch all users
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userControllerFetchAllUsers(options?: AxiosRequestConfig): AxiosPromise<Array<UserResponseDto>>;

    /**
     * Fetch user by ID
     * @summary 
     * @param {any} userId Get user by ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userControllerFetchUserById(userId: any, options?: AxiosRequestConfig): AxiosPromise<UserResponseDto>;

    /**
     * Fetch user by account
     * @summary 
     * @param {any} accountId Account ID, e.g. discord user ID
     * @param {'discord' | 'ethereum'} providerId ID of account provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userControllerFetchUserByProvider(accountId: any, providerId: 'discord' | 'ethereum', options?: AxiosRequestConfig): AxiosPromise<UserResponseDto>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * Fetch all users
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerFetchAllUsers(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerFetchAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch user by ID
     * @summary 
     * @param {any} userId Get user by ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerFetchUserById(userId: any, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerFetchUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch user by account
     * @summary 
     * @param {any} accountId Account ID, e.g. discord user ID
     * @param {'discord' | 'ethereum'} providerId ID of account provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerFetchUserByProvider(accountId: any, providerId: 'discord' | 'ethereum', options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerFetchUserByProvider(accountId, providerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VoteApi - axios parameter creator
 * @export
 */
export const VoteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submit a vote
         * @summary 
         * @param {any} pollId ID of poll to vote on
         * @param {VoteRequestDto} voteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteControllerCreateVote: async (pollId: any, voteRequestDto: VoteRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pollId' is not null or undefined
            assertParamExists('voteControllerCreateVote', 'pollId', pollId)
            // verify required parameter 'voteRequestDto' is not null or undefined
            assertParamExists('voteControllerCreateVote', 'voteRequestDto', voteRequestDto)
            const localVarPath = `/api/vote/{poll_id}`
                .replace(`{${"poll_id"}}`, encodeURIComponent(String(pollId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(voteRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch votes by poll and user
         * @summary 
         * @param {any} userId Governator user ID
         * @param {any} pollId Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteControllerFetchVoteByPollAndUserCountAggregate: async (userId: any, pollId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('voteControllerFetchVoteByPollAndUserCountAggregate', 'userId', userId)
            // verify required parameter 'pollId' is not null or undefined
            assertParamExists('voteControllerFetchVoteByPollAndUserCountAggregate', 'pollId', pollId)
            const localVarPath = `/api/vote/results/count/{poll_id}/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"poll_id"}}`, encodeURIComponent(String(pollId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch votes by poll
         * @summary 
         * @param {any} pollId Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteControllerFetchVoteByPollCountAggregate: async (pollId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pollId' is not null or undefined
            assertParamExists('voteControllerFetchVoteByPollCountAggregate', 'pollId', pollId)
            const localVarPath = `/api/vote/results/count/{poll_id}`
                .replace(`{${"poll_id"}}`, encodeURIComponent(String(pollId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch votes by poll
         * @summary 
         * @param {any} pollId Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteControllerFetchVoteByPollSumAggregate: async (pollId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pollId' is not null or undefined
            assertParamExists('voteControllerFetchVoteByPollSumAggregate', 'pollId', pollId)
            const localVarPath = `/api/vote/results/sum/{poll_id}`
                .replace(`{${"poll_id"}}`, encodeURIComponent(String(pollId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch votes per user
         * @summary 
         * @param {any} pollId Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteControllerFetchVoteUserCount: async (pollId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pollId' is not null or undefined
            assertParamExists('voteControllerFetchVoteUserCount', 'pollId', pollId)
            const localVarPath = `/api/vote/results/votes-per-user/count/{poll_id}`
                .replace(`{${"poll_id"}}`, encodeURIComponent(String(pollId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoteApi - functional programming interface
 * @export
 */
export const VoteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VoteApiAxiosParamCreator(configuration)
    return {
        /**
         * Submit a vote
         * @summary 
         * @param {any} pollId ID of poll to vote on
         * @param {VoteRequestDto} voteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voteControllerCreateVote(pollId: any, voteRequestDto: VoteRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VoteResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voteControllerCreateVote(pollId, voteRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch votes by poll and user
         * @summary 
         * @param {any} userId Governator user ID
         * @param {any} pollId Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voteControllerFetchVoteByPollAndUserCountAggregate(userId: any, pollId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voteControllerFetchVoteByPollAndUserCountAggregate(userId, pollId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch votes by poll
         * @summary 
         * @param {any} pollId Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voteControllerFetchVoteByPollCountAggregate(pollId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voteControllerFetchVoteByPollCountAggregate(pollId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch votes by poll
         * @summary 
         * @param {any} pollId Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voteControllerFetchVoteByPollSumAggregate(pollId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voteControllerFetchVoteByPollSumAggregate(pollId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch votes per user
         * @summary 
         * @param {any} pollId Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voteControllerFetchVoteUserCount(pollId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voteControllerFetchVoteUserCount(pollId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VoteApi - factory interface
 * @export
 */
export const VoteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VoteApiFp(configuration)
    return {
        /**
         * Submit a vote
         * @summary 
         * @param {any} pollId ID of poll to vote on
         * @param {VoteRequestDto} voteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteControllerCreateVote(pollId: any, voteRequestDto: VoteRequestDto, options?: any): AxiosPromise<Array<VoteResponseDto>> {
            return localVarFp.voteControllerCreateVote(pollId, voteRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch votes by poll and user
         * @summary 
         * @param {any} userId Governator user ID
         * @param {any} pollId Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteControllerFetchVoteByPollAndUserCountAggregate(userId: any, pollId: any, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.voteControllerFetchVoteByPollAndUserCountAggregate(userId, pollId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch votes by poll
         * @summary 
         * @param {any} pollId Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteControllerFetchVoteByPollCountAggregate(pollId: any, options?: any): AxiosPromise<object> {
            return localVarFp.voteControllerFetchVoteByPollCountAggregate(pollId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch votes by poll
         * @summary 
         * @param {any} pollId Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteControllerFetchVoteByPollSumAggregate(pollId: any, options?: any): AxiosPromise<object> {
            return localVarFp.voteControllerFetchVoteByPollSumAggregate(pollId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch votes per user
         * @summary 
         * @param {any} pollId Poll ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voteControllerFetchVoteUserCount(pollId: any, options?: any): AxiosPromise<string> {
            return localVarFp.voteControllerFetchVoteUserCount(pollId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoteApi - interface
 * @export
 * @interface VoteApi
 */
export interface VoteApiInterface {
    /**
     * Submit a vote
     * @summary 
     * @param {any} pollId ID of poll to vote on
     * @param {VoteRequestDto} voteRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoteApiInterface
     */
    voteControllerCreateVote(pollId: any, voteRequestDto: VoteRequestDto, options?: AxiosRequestConfig): AxiosPromise<Array<VoteResponseDto>>;

    /**
     * Fetch votes by poll and user
     * @summary 
     * @param {any} userId Governator user ID
     * @param {any} pollId Poll ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoteApiInterface
     */
    voteControllerFetchVoteByPollAndUserCountAggregate(userId: any, pollId: any, options?: AxiosRequestConfig): AxiosPromise<Array<object>>;

    /**
     * Fetch votes by poll
     * @summary 
     * @param {any} pollId Poll ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoteApiInterface
     */
    voteControllerFetchVoteByPollCountAggregate(pollId: any, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * Fetch votes by poll
     * @summary 
     * @param {any} pollId Poll ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoteApiInterface
     */
    voteControllerFetchVoteByPollSumAggregate(pollId: any, options?: AxiosRequestConfig): AxiosPromise<object>;

    /**
     * Fetch votes per user
     * @summary 
     * @param {any} pollId Poll ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoteApiInterface
     */
    voteControllerFetchVoteUserCount(pollId: any, options?: AxiosRequestConfig): AxiosPromise<string>;

}

/**
 * VoteApi - object-oriented interface
 * @export
 * @class VoteApi
 * @extends {BaseAPI}
 */
export class VoteApi extends BaseAPI implements VoteApiInterface {
    /**
     * Submit a vote
     * @summary 
     * @param {any} pollId ID of poll to vote on
     * @param {VoteRequestDto} voteRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoteApi
     */
    public voteControllerCreateVote(pollId: any, voteRequestDto: VoteRequestDto, options?: AxiosRequestConfig) {
        return VoteApiFp(this.configuration).voteControllerCreateVote(pollId, voteRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch votes by poll and user
     * @summary 
     * @param {any} userId Governator user ID
     * @param {any} pollId Poll ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoteApi
     */
    public voteControllerFetchVoteByPollAndUserCountAggregate(userId: any, pollId: any, options?: AxiosRequestConfig) {
        return VoteApiFp(this.configuration).voteControllerFetchVoteByPollAndUserCountAggregate(userId, pollId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch votes by poll
     * @summary 
     * @param {any} pollId Poll ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoteApi
     */
    public voteControllerFetchVoteByPollCountAggregate(pollId: any, options?: AxiosRequestConfig) {
        return VoteApiFp(this.configuration).voteControllerFetchVoteByPollCountAggregate(pollId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch votes by poll
     * @summary 
     * @param {any} pollId Poll ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoteApi
     */
    public voteControllerFetchVoteByPollSumAggregate(pollId: any, options?: AxiosRequestConfig) {
        return VoteApiFp(this.configuration).voteControllerFetchVoteByPollSumAggregate(pollId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch votes per user
     * @summary 
     * @param {any} pollId Poll ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoteApi
     */
    public voteControllerFetchVoteUserCount(pollId: any, options?: AxiosRequestConfig) {
        return VoteApiFp(this.configuration).voteControllerFetchVoteUserCount(pollId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * W3SIWEApi - axios parameter creator
 * @export
 */
export const W3SIWEApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get nonce
         * @summary 
         * @param {string} id Ethereum account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siweControllerGetNonce: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('siweControllerGetNonce', 'id', id)
            const localVarPath = `/api/siwe/nonce/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify signature
         * @summary 
         * @param {SiweVerifyDto} siweVerifyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siweControllerVerifySignature: async (siweVerifyDto: SiweVerifyDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'siweVerifyDto' is not null or undefined
            assertParamExists('siweControllerVerifySignature', 'siweVerifyDto', siweVerifyDto)
            const localVarPath = `/api/siwe/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(siweVerifyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * W3SIWEApi - functional programming interface
 * @export
 */
export const W3SIWEApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = W3SIWEApiAxiosParamCreator(configuration)
    return {
        /**
         * Get nonce
         * @summary 
         * @param {string} id Ethereum account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siweControllerGetNonce(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siweControllerGetNonce(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify signature
         * @summary 
         * @param {SiweVerifyDto} siweVerifyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siweControllerVerifySignature(siweVerifyDto: SiweVerifyDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EthereumAccountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siweControllerVerifySignature(siweVerifyDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * W3SIWEApi - factory interface
 * @export
 */
export const W3SIWEApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = W3SIWEApiFp(configuration)
    return {
        /**
         * Get nonce
         * @summary 
         * @param {string} id Ethereum account address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siweControllerGetNonce(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.siweControllerGetNonce(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify signature
         * @summary 
         * @param {SiweVerifyDto} siweVerifyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siweControllerVerifySignature(siweVerifyDto: SiweVerifyDto, options?: any): AxiosPromise<EthereumAccountResponseDto> {
            return localVarFp.siweControllerVerifySignature(siweVerifyDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * W3SIWEApi - interface
 * @export
 * @interface W3SIWEApi
 */
export interface W3SIWEApiInterface {
    /**
     * Get nonce
     * @summary 
     * @param {string} id Ethereum account address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3SIWEApiInterface
     */
    siweControllerGetNonce(id: string, options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * Verify signature
     * @summary 
     * @param {SiweVerifyDto} siweVerifyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3SIWEApiInterface
     */
    siweControllerVerifySignature(siweVerifyDto: SiweVerifyDto, options?: AxiosRequestConfig): AxiosPromise<EthereumAccountResponseDto>;

}

/**
 * W3SIWEApi - object-oriented interface
 * @export
 * @class W3SIWEApi
 * @extends {BaseAPI}
 */
export class W3SIWEApi extends BaseAPI implements W3SIWEApiInterface {
    /**
     * Get nonce
     * @summary 
     * @param {string} id Ethereum account address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3SIWEApi
     */
    public siweControllerGetNonce(id: string, options?: AxiosRequestConfig) {
        return W3SIWEApiFp(this.configuration).siweControllerGetNonce(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify signature
     * @summary 
     * @param {SiweVerifyDto} siweVerifyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3SIWEApi
     */
    public siweControllerVerifySignature(siweVerifyDto: SiweVerifyDto, options?: AxiosRequestConfig) {
        return W3SIWEApiFp(this.configuration).siweControllerVerifySignature(siweVerifyDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * W3TokenVotingApi - axios parameter creator
 * @export
 */
export const W3TokenVotingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get ERC721 token balances of given address and token list
         * @summary 
         * @param {string} id Ethereum account address
         * @param {ERC1155BalanceOfDto} eRC1155BalanceOfDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evmControllerGetErc1155BalanceOf: async (id: string, eRC1155BalanceOfDto: ERC1155BalanceOfDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('evmControllerGetErc1155BalanceOf', 'id', id)
            // verify required parameter 'eRC1155BalanceOfDto' is not null or undefined
            assertParamExists('evmControllerGetErc1155BalanceOf', 'eRC1155BalanceOfDto', eRC1155BalanceOfDto)
            const localVarPath = `/api/token-voting/erc1155-balance-of/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eRC1155BalanceOfDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get ERC20 token balances of given address and token list
         * @summary 
         * @param {string} id Ethereum account address
         * @param {TokenList} tokenList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evmControllerGetErc20TokenBalances: async (id: string, tokenList: TokenList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('evmControllerGetErc20TokenBalances', 'id', id)
            // verify required parameter 'tokenList' is not null or undefined
            assertParamExists('evmControllerGetErc20TokenBalances', 'tokenList', tokenList)
            const localVarPath = `/api/token-voting/erc20-balance-of/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get owner addresses for given list of ERC721 token IDs
         * @summary 
         * @param {ERC721OwnerOfDto} eRC721OwnerOfDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evmControllerGetErc721OwnerOf: async (eRC721OwnerOfDto: ERC721OwnerOfDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eRC721OwnerOfDto' is not null or undefined
            assertParamExists('evmControllerGetErc721OwnerOf', 'eRC721OwnerOfDto', eRC721OwnerOfDto)
            const localVarPath = `/api/token-voting/erc721-owner-of`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eRC721OwnerOfDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get ERC721 token balances of given address and token list
         * @summary 
         * @param {string} id Ethereum account address
         * @param {TokenList} tokenList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evmControllerGetErc721TokenBalances: async (id: string, tokenList: TokenList, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('evmControllerGetErc721TokenBalances', 'id', id)
            // verify required parameter 'tokenList' is not null or undefined
            assertParamExists('evmControllerGetErc721TokenBalances', 'tokenList', tokenList)
            const localVarPath = `/api/token-voting/erc721-balance-of/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * W3TokenVotingApi - functional programming interface
 * @export
 */
export const W3TokenVotingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = W3TokenVotingApiAxiosParamCreator(configuration)
    return {
        /**
         * Get ERC721 token balances of given address and token list
         * @summary 
         * @param {string} id Ethereum account address
         * @param {ERC1155BalanceOfDto} eRC1155BalanceOfDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evmControllerGetErc1155BalanceOf(id: string, eRC1155BalanceOfDto: ERC1155BalanceOfDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ERC20TokenBalances>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evmControllerGetErc1155BalanceOf(id, eRC1155BalanceOfDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get ERC20 token balances of given address and token list
         * @summary 
         * @param {string} id Ethereum account address
         * @param {TokenList} tokenList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evmControllerGetErc20TokenBalances(id: string, tokenList: TokenList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ERC20TokenBalances>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evmControllerGetErc20TokenBalances(id, tokenList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get owner addresses for given list of ERC721 token IDs
         * @summary 
         * @param {ERC721OwnerOfDto} eRC721OwnerOfDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evmControllerGetErc721OwnerOf(eRC721OwnerOfDto: ERC721OwnerOfDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evmControllerGetErc721OwnerOf(eRC721OwnerOfDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get ERC721 token balances of given address and token list
         * @summary 
         * @param {string} id Ethereum account address
         * @param {TokenList} tokenList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evmControllerGetErc721TokenBalances(id: string, tokenList: TokenList, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ERC20TokenBalances>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evmControllerGetErc721TokenBalances(id, tokenList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * W3TokenVotingApi - factory interface
 * @export
 */
export const W3TokenVotingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = W3TokenVotingApiFp(configuration)
    return {
        /**
         * Get ERC721 token balances of given address and token list
         * @summary 
         * @param {string} id Ethereum account address
         * @param {ERC1155BalanceOfDto} eRC1155BalanceOfDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evmControllerGetErc1155BalanceOf(id: string, eRC1155BalanceOfDto: ERC1155BalanceOfDto, options?: any): AxiosPromise<ERC20TokenBalances> {
            return localVarFp.evmControllerGetErc1155BalanceOf(id, eRC1155BalanceOfDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Get ERC20 token balances of given address and token list
         * @summary 
         * @param {string} id Ethereum account address
         * @param {TokenList} tokenList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evmControllerGetErc20TokenBalances(id: string, tokenList: TokenList, options?: any): AxiosPromise<ERC20TokenBalances> {
            return localVarFp.evmControllerGetErc20TokenBalances(id, tokenList, options).then((request) => request(axios, basePath));
        },
        /**
         * Get owner addresses for given list of ERC721 token IDs
         * @summary 
         * @param {ERC721OwnerOfDto} eRC721OwnerOfDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evmControllerGetErc721OwnerOf(eRC721OwnerOfDto: ERC721OwnerOfDto, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.evmControllerGetErc721OwnerOf(eRC721OwnerOfDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Get ERC721 token balances of given address and token list
         * @summary 
         * @param {string} id Ethereum account address
         * @param {TokenList} tokenList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evmControllerGetErc721TokenBalances(id: string, tokenList: TokenList, options?: any): AxiosPromise<ERC20TokenBalances> {
            return localVarFp.evmControllerGetErc721TokenBalances(id, tokenList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * W3TokenVotingApi - interface
 * @export
 * @interface W3TokenVotingApi
 */
export interface W3TokenVotingApiInterface {
    /**
     * Get ERC721 token balances of given address and token list
     * @summary 
     * @param {string} id Ethereum account address
     * @param {ERC1155BalanceOfDto} eRC1155BalanceOfDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenVotingApiInterface
     */
    evmControllerGetErc1155BalanceOf(id: string, eRC1155BalanceOfDto: ERC1155BalanceOfDto, options?: AxiosRequestConfig): AxiosPromise<ERC20TokenBalances>;

    /**
     * Get ERC20 token balances of given address and token list
     * @summary 
     * @param {string} id Ethereum account address
     * @param {TokenList} tokenList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenVotingApiInterface
     */
    evmControllerGetErc20TokenBalances(id: string, tokenList: TokenList, options?: AxiosRequestConfig): AxiosPromise<ERC20TokenBalances>;

    /**
     * Get owner addresses for given list of ERC721 token IDs
     * @summary 
     * @param {ERC721OwnerOfDto} eRC721OwnerOfDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenVotingApiInterface
     */
    evmControllerGetErc721OwnerOf(eRC721OwnerOfDto: ERC721OwnerOfDto, options?: AxiosRequestConfig): AxiosPromise<Array<string>>;

    /**
     * Get ERC721 token balances of given address and token list
     * @summary 
     * @param {string} id Ethereum account address
     * @param {TokenList} tokenList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenVotingApiInterface
     */
    evmControllerGetErc721TokenBalances(id: string, tokenList: TokenList, options?: AxiosRequestConfig): AxiosPromise<ERC20TokenBalances>;

}

/**
 * W3TokenVotingApi - object-oriented interface
 * @export
 * @class W3TokenVotingApi
 * @extends {BaseAPI}
 */
export class W3TokenVotingApi extends BaseAPI implements W3TokenVotingApiInterface {
    /**
     * Get ERC721 token balances of given address and token list
     * @summary 
     * @param {string} id Ethereum account address
     * @param {ERC1155BalanceOfDto} eRC1155BalanceOfDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenVotingApi
     */
    public evmControllerGetErc1155BalanceOf(id: string, eRC1155BalanceOfDto: ERC1155BalanceOfDto, options?: AxiosRequestConfig) {
        return W3TokenVotingApiFp(this.configuration).evmControllerGetErc1155BalanceOf(id, eRC1155BalanceOfDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get ERC20 token balances of given address and token list
     * @summary 
     * @param {string} id Ethereum account address
     * @param {TokenList} tokenList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenVotingApi
     */
    public evmControllerGetErc20TokenBalances(id: string, tokenList: TokenList, options?: AxiosRequestConfig) {
        return W3TokenVotingApiFp(this.configuration).evmControllerGetErc20TokenBalances(id, tokenList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get owner addresses for given list of ERC721 token IDs
     * @summary 
     * @param {ERC721OwnerOfDto} eRC721OwnerOfDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenVotingApi
     */
    public evmControllerGetErc721OwnerOf(eRC721OwnerOfDto: ERC721OwnerOfDto, options?: AxiosRequestConfig) {
        return W3TokenVotingApiFp(this.configuration).evmControllerGetErc721OwnerOf(eRC721OwnerOfDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get ERC721 token balances of given address and token list
     * @summary 
     * @param {string} id Ethereum account address
     * @param {TokenList} tokenList 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenVotingApi
     */
    public evmControllerGetErc721TokenBalances(id: string, tokenList: TokenList, options?: AxiosRequestConfig) {
        return W3TokenVotingApiFp(this.configuration).evmControllerGetErc721TokenBalances(id, tokenList, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * W3TokenWhitelistApi - axios parameter creator
 * @export
 */
export const W3TokenWhitelistApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Whitelist a token
         * @summary 
         * @param {TokenWhitelistCreateDto} tokenWhitelistCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWhitelistControllerCreateTokenWhitelist: async (tokenWhitelistCreateDto: TokenWhitelistCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenWhitelistCreateDto' is not null or undefined
            assertParamExists('tokenWhitelistControllerCreateTokenWhitelist', 'tokenWhitelistCreateDto', tokenWhitelistCreateDto)
            const localVarPath = `/api/token-whitelist/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenWhitelistCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all whitelisted tokens
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWhitelistControllerFindAllTokenWhitelist: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/token-whitelist/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all whitelisted tokens of specified ERC type
         * @summary 
         * @param {20 | 721 | 1155} erc Type of token ERC standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWhitelistControllerFindAllTokenWhitelistERC: async (erc: 20 | 721 | 1155, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'erc' is not null or undefined
            assertParamExists('tokenWhitelistControllerFindAllTokenWhitelistERC', 'erc', erc)
            const localVarPath = `/api/token-whitelist/list/{erc}`
                .replace(`{${"erc"}}`, encodeURIComponent(String(erc)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find a token by contract address
         * @summary 
         * @param {any} chainId Chain ID
         * @param {any} contractAddress Token contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWhitelistControllerFindManyTokenWhitelist: async (chainId: any, contractAddress: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chainId' is not null or undefined
            assertParamExists('tokenWhitelistControllerFindManyTokenWhitelist', 'chainId', chainId)
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('tokenWhitelistControllerFindManyTokenWhitelist', 'contractAddress', contractAddress)
            const localVarPath = `/api/token-whitelist/find/{contractAddress}/{chain_id}`
                .replace(`{${"chain_id"}}`, encodeURIComponent(String(chainId)))
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a token
         * @summary 
         * @param {any} chainId Chain ID
         * @param {any} contractAddress Token contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWhitelistControllerFindOneAndDeleteTokenWhitelist: async (chainId: any, contractAddress: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chainId' is not null or undefined
            assertParamExists('tokenWhitelistControllerFindOneAndDeleteTokenWhitelist', 'chainId', chainId)
            // verify required parameter 'contractAddress' is not null or undefined
            assertParamExists('tokenWhitelistControllerFindOneAndDeleteTokenWhitelist', 'contractAddress', contractAddress)
            const localVarPath = `/api/token-whitelist/delete/{contractAddress}/{chain_id}`
                .replace(`{${"chain_id"}}`, encodeURIComponent(String(chainId)))
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * W3TokenWhitelistApi - functional programming interface
 * @export
 */
export const W3TokenWhitelistApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = W3TokenWhitelistApiAxiosParamCreator(configuration)
    return {
        /**
         * Whitelist a token
         * @summary 
         * @param {TokenWhitelistCreateDto} tokenWhitelistCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenWhitelistControllerCreateTokenWhitelist(tokenWhitelistCreateDto: TokenWhitelistCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenWhitelistResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenWhitelistControllerCreateTokenWhitelist(tokenWhitelistCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all whitelisted tokens
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenWhitelistControllerFindAllTokenWhitelist(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenWhitelistResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenWhitelistControllerFindAllTokenWhitelist(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all whitelisted tokens of specified ERC type
         * @summary 
         * @param {20 | 721 | 1155} erc Type of token ERC standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenWhitelistControllerFindAllTokenWhitelistERC(erc: 20 | 721 | 1155, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenWhitelistResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenWhitelistControllerFindAllTokenWhitelistERC(erc, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find a token by contract address
         * @summary 
         * @param {any} chainId Chain ID
         * @param {any} contractAddress Token contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenWhitelistControllerFindManyTokenWhitelist(chainId: any, contractAddress: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenWhitelistResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenWhitelistControllerFindManyTokenWhitelist(chainId, contractAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a token
         * @summary 
         * @param {any} chainId Chain ID
         * @param {any} contractAddress Token contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenWhitelistControllerFindOneAndDeleteTokenWhitelist(chainId: any, contractAddress: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenWhitelistResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenWhitelistControllerFindOneAndDeleteTokenWhitelist(chainId, contractAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * W3TokenWhitelistApi - factory interface
 * @export
 */
export const W3TokenWhitelistApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = W3TokenWhitelistApiFp(configuration)
    return {
        /**
         * Whitelist a token
         * @summary 
         * @param {TokenWhitelistCreateDto} tokenWhitelistCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWhitelistControllerCreateTokenWhitelist(tokenWhitelistCreateDto: TokenWhitelistCreateDto, options?: any): AxiosPromise<TokenWhitelistResponseDto> {
            return localVarFp.tokenWhitelistControllerCreateTokenWhitelist(tokenWhitelistCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * List all whitelisted tokens
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWhitelistControllerFindAllTokenWhitelist(options?: any): AxiosPromise<Array<TokenWhitelistResponseDto>> {
            return localVarFp.tokenWhitelistControllerFindAllTokenWhitelist(options).then((request) => request(axios, basePath));
        },
        /**
         * List all whitelisted tokens of specified ERC type
         * @summary 
         * @param {20 | 721 | 1155} erc Type of token ERC standard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWhitelistControllerFindAllTokenWhitelistERC(erc: 20 | 721 | 1155, options?: any): AxiosPromise<Array<TokenWhitelistResponseDto>> {
            return localVarFp.tokenWhitelistControllerFindAllTokenWhitelistERC(erc, options).then((request) => request(axios, basePath));
        },
        /**
         * Find a token by contract address
         * @summary 
         * @param {any} chainId Chain ID
         * @param {any} contractAddress Token contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWhitelistControllerFindManyTokenWhitelist(chainId: any, contractAddress: any, options?: any): AxiosPromise<TokenWhitelistResponseDto> {
            return localVarFp.tokenWhitelistControllerFindManyTokenWhitelist(chainId, contractAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a token
         * @summary 
         * @param {any} chainId Chain ID
         * @param {any} contractAddress Token contract address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWhitelistControllerFindOneAndDeleteTokenWhitelist(chainId: any, contractAddress: any, options?: any): AxiosPromise<TokenWhitelistResponseDto> {
            return localVarFp.tokenWhitelistControllerFindOneAndDeleteTokenWhitelist(chainId, contractAddress, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * W3TokenWhitelistApi - interface
 * @export
 * @interface W3TokenWhitelistApi
 */
export interface W3TokenWhitelistApiInterface {
    /**
     * Whitelist a token
     * @summary 
     * @param {TokenWhitelistCreateDto} tokenWhitelistCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenWhitelistApiInterface
     */
    tokenWhitelistControllerCreateTokenWhitelist(tokenWhitelistCreateDto: TokenWhitelistCreateDto, options?: AxiosRequestConfig): AxiosPromise<TokenWhitelistResponseDto>;

    /**
     * List all whitelisted tokens
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenWhitelistApiInterface
     */
    tokenWhitelistControllerFindAllTokenWhitelist(options?: AxiosRequestConfig): AxiosPromise<Array<TokenWhitelistResponseDto>>;

    /**
     * List all whitelisted tokens of specified ERC type
     * @summary 
     * @param {20 | 721 | 1155} erc Type of token ERC standard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenWhitelistApiInterface
     */
    tokenWhitelistControllerFindAllTokenWhitelistERC(erc: 20 | 721 | 1155, options?: AxiosRequestConfig): AxiosPromise<Array<TokenWhitelistResponseDto>>;

    /**
     * Find a token by contract address
     * @summary 
     * @param {any} chainId Chain ID
     * @param {any} contractAddress Token contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenWhitelistApiInterface
     */
    tokenWhitelistControllerFindManyTokenWhitelist(chainId: any, contractAddress: any, options?: AxiosRequestConfig): AxiosPromise<TokenWhitelistResponseDto>;

    /**
     * Delete a token
     * @summary 
     * @param {any} chainId Chain ID
     * @param {any} contractAddress Token contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenWhitelistApiInterface
     */
    tokenWhitelistControllerFindOneAndDeleteTokenWhitelist(chainId: any, contractAddress: any, options?: AxiosRequestConfig): AxiosPromise<TokenWhitelistResponseDto>;

}

/**
 * W3TokenWhitelistApi - object-oriented interface
 * @export
 * @class W3TokenWhitelistApi
 * @extends {BaseAPI}
 */
export class W3TokenWhitelistApi extends BaseAPI implements W3TokenWhitelistApiInterface {
    /**
     * Whitelist a token
     * @summary 
     * @param {TokenWhitelistCreateDto} tokenWhitelistCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenWhitelistApi
     */
    public tokenWhitelistControllerCreateTokenWhitelist(tokenWhitelistCreateDto: TokenWhitelistCreateDto, options?: AxiosRequestConfig) {
        return W3TokenWhitelistApiFp(this.configuration).tokenWhitelistControllerCreateTokenWhitelist(tokenWhitelistCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all whitelisted tokens
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenWhitelistApi
     */
    public tokenWhitelistControllerFindAllTokenWhitelist(options?: AxiosRequestConfig) {
        return W3TokenWhitelistApiFp(this.configuration).tokenWhitelistControllerFindAllTokenWhitelist(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all whitelisted tokens of specified ERC type
     * @summary 
     * @param {20 | 721 | 1155} erc Type of token ERC standard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenWhitelistApi
     */
    public tokenWhitelistControllerFindAllTokenWhitelistERC(erc: 20 | 721 | 1155, options?: AxiosRequestConfig) {
        return W3TokenWhitelistApiFp(this.configuration).tokenWhitelistControllerFindAllTokenWhitelistERC(erc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find a token by contract address
     * @summary 
     * @param {any} chainId Chain ID
     * @param {any} contractAddress Token contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenWhitelistApi
     */
    public tokenWhitelistControllerFindManyTokenWhitelist(chainId: any, contractAddress: any, options?: AxiosRequestConfig) {
        return W3TokenWhitelistApiFp(this.configuration).tokenWhitelistControllerFindManyTokenWhitelist(chainId, contractAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a token
     * @summary 
     * @param {any} chainId Chain ID
     * @param {any} contractAddress Token contract address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof W3TokenWhitelistApi
     */
    public tokenWhitelistControllerFindOneAndDeleteTokenWhitelist(chainId: any, contractAddress: any, options?: AxiosRequestConfig) {
        return W3TokenWhitelistApiFp(this.configuration).tokenWhitelistControllerFindOneAndDeleteTokenWhitelist(chainId, contractAddress, options).then((request) => request(this.axios, this.basePath));
    }
}


